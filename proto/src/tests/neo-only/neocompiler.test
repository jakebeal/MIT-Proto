// a place to put some complex, composed programs

$(P2B_ARGS) = --no-localization

test: $(P2B) --test
is 0 _ foo: Attributes [2]
is 1 _   CONTEXT: sample:2-5, simple:7-8, wimple:3
is 2 _   RANDOM: rnd:0
is 3 _ bar: Attributes [0]
is 4 _ baz: Attributes [1]
is 5 _   CONTEXT: sample:2-5, simple:7-8, wimple:3
is 6 _ (1 (2 3) 4 ((5) 6))
is 7 _ (quasiquote (this (comma-splice (is (comma really))) (quote splicy)))
is 8 _ (all here be symbols)
is 9 _ cmdline:1: Wrapper macro comma is not applied to anything
is 10 _ cmdline:1: Missing right parenthesis
is 11 _ Parse failed!
is 12 _ cmdline:1: Illegal use of reserved character '~'
is 13 _ Parse failed!
// unrecognized character shows up differently on different platforms
is 15 _ Parse failed!
is 16 _ (all this | is | bar | separated)
is 17 _ Found 1
is 18 _ Platform description file is not a parsable 'single enum' file: wrong location of '}' .
is 19 _ Enum parse failed!


test: $(P2B) --internal-tests
is 0 _ Testing type relations:
is 1 _ Generic types:
is 2 _ <Any> > <Any>: TRUE, reverse: TRUE
is 3 _ <Any> > <Local>: TRUE, reverse: FALSE
is 4 _ <Any> > <Field <Any>>: TRUE, reverse: FALSE
is 5 _ <Any> > <Lambda>: TRUE, reverse: FALSE
is 6 _ <Any> > <Scalar>: TRUE, reverse: FALSE
is 7 _ <Scalar> > <Number>: FALSE, reverse: TRUE
is 8 _ <Scalar> > <Field <Any>>: FALSE, reverse: FALSE
is 9 _ <Vector<Scalar>...> > <Tuple<Any>...>: FALSE, reverse: TRUE
is 10 _ <Scalar> > <Boolean>: TRUE, reverse: FALSE
is 11 _ <Scalar> > <Symbol>: FALSE, reverse: FALSE
is 12 _ <Any> > <Vector<Scalar>...>: TRUE, reverse: FALSE
is 13 _ <Vector<Scalar>...> > <Number>: FALSE, reverse: TRUE
is 14 _ <Vector<Scalar>...> > <Boolean>: FALSE, reverse: FALSE
is 15 _ <Symbol> > <Boolean>: FALSE, reverse: FALSE
is 16 _ <Symbol> > <Local>: FALSE, reverse: TRUE
is 17 _ <Field <Any>> > <Local>: FALSE, reverse: FALSE
is 18 _ <Lambda> > <Local>: FALSE, reverse: TRUE
is 19 _ <Tuple<Any>...> > <Local>: FALSE, reverse: TRUE
is 20 _ Literals:
is 21 _ <Scalar 3> > <Local>: FALSE, reverse: TRUE
is 22 _ <Scalar 4> > <Scalar 5>: FALSE, reverse: FALSE
is 23 _ <Scalar 4> > <Boolean>: FALSE, reverse: FALSE
is 24 _ <Scalar> > <Scalar 3>: TRUE, reverse: FALSE
is 25 _ <Boolean true> > <Boolean>: FALSE, reverse: TRUE
is 26 _ <Boolean false> > <Symbol>: FALSE, reverse: FALSE
is 27 _ <Boolean> > <Boolean false>: TRUE, reverse: FALSE
is 28 _ <Boolean false> > <Boolean true>: FALSE, reverse: FALSE
is 29 _ <Boolean false> > <Scalar 1>: FALSE, reverse: FALSE
is 30 _ <Boolean false> > <Scalar 0>: FALSE, reverse: TRUE
is 31 _ <Boolean true> > <Scalar 1>: FALSE, reverse: TRUE
is 32 _ <Boolean true> > <Scalar 0>: FALSE, reverse: FALSE
is 33 _ <Symbol foo> > <Number>: FALSE, reverse: FALSE
is 34 _ <Symbol bar> > <Symbol>: FALSE, reverse: TRUE
is 35 _ <Any> > <Symbol foo>: TRUE, reverse: FALSE
is 36 _ <Symbol foo> > <Symbol bar>: FALSE, reverse: FALSE
is 37 _ Tuples:
is 38 _ <2-Tuple<Scalar 3>,<Symbol>> > <Tuple<Scalar 3>,<Any>,<Field <Any>>...>: FALSE, reverse: TRUE
is 39 _ <2-Tuple<Scalar 3>,<Symbol>> > <Tuple<Any>...>: FALSE, reverse: TRUE
is 40 _ <Tuple<Scalar 3>,<Any>,<Field <Any>>...> > <Tuple<Any>...>: FALSE, reverse: TRUE
is 41 _ <Tuple<Any>...> > <Tuple<Scalar 3>,<Scalar 4>,<Scalar>...>: TRUE, reverse: FALSE
is 42 _ <Tuple<Scalar 3>,<Scalar 4>,<Scalar 5>,<Scalar>...> > <Tuple<Scalar 3>,<Scalar 4>,<Scalar>...>: FALSE, reverse: TRUE
is 43 _ <3-Tuple<Scalar 3>,<Scalar 4>,<Scalar 5>> > <Tuple<Scalar 3>,<Scalar 4>,<Scalar>...>: FALSE, reverse: TRUE
is 44 _ <3-Tuple<Scalar 3>,<Any>,<Scalar 5>> > <Tuple<Scalar 3>,<Scalar 4>,<Scalar>...>: FALSE, reverse: FALSE
is 45 _ <2-Tuple<Scalar 3>,<Scalar 4>> > <Tuple<Scalar 3>,<Scalar 4>,<Scalar>...>: FALSE, reverse: TRUE
is 46 _ <3-Tuple<Scalar 3>,<3-Tuple<Scalar 3>,<Scalar 4>,<Scalar 5>>,<Scalar 5>> > <Tuple<Scalar 3>,<Scalar 4>,<Scalar>...>: FALSE, reverse: FALSE
is 47 _ <3-Tuple<Scalar 3>,<Scalar 4>,<Scalar 5>> > <Tuple<Scalar 3>,<Scalar 4>,<Scalar 5>,<Scalar>...>: FALSE, reverse: TRUE
is 48 _ <3-Tuple<Scalar 3>,<Any>,<Scalar 5>> > <Tuple<Scalar 3>,<Scalar 4>,<Scalar 5>,<Scalar>...>: FALSE, reverse: FALSE
is 49 _ <2-Tuple<Scalar 3>,<Scalar 4>> > <Tuple<Scalar 3>,<Scalar 4>,<Scalar 5>,<Scalar>...>: FALSE, reverse: FALSE
is 50 _ <3-Tuple<Scalar 3>,<Any>,<Scalar 5>> > <3-Tuple<Scalar 3>,<Scalar 4>,<Scalar 5>>: TRUE, reverse: FALSE
is 51 _ <3-Tuple<Scalar 3>,<Any>,<Scalar 5>> > <2-Tuple<Scalar 3>,<Scalar 4>>: FALSE, reverse: FALSE
is 52 _ <3-Tuple<Scalar 3>,<Any>,<Scalar 5>> > <3-Tuple<Scalar 3>,<3-Tuple<Scalar 3>,<Scalar 4>,<Scalar 5>>,<Scalar 5>>: TRUE, reverse: FALSE
is 53 _ <Tuple<Scalar 3>,<Scalar 4>,<Scalar>,<Scalar>...> > <Tuple<Scalar 3>,<Scalar 4>,<Scalar>...>: TRUE, reverse: TRUE
is 54 _ <Tuple<Scalar 3>,<Scalar 4>,<Scalar>,<Scalar>...> > <Tuple<Scalar 3>,<Scalar 4>,<Scalar 5>,<Scalar>...>: TRUE, reverse: FALSE
is 55 _ <Tuple<Scalar 3>,<Scalar 4>,<Scalar>,<Scalar>...> > <3-Tuple<Scalar 3>,<Scalar 4>,<Scalar 5>>: TRUE, reverse: FALSE
is 56 _ <Tuple<Scalar 3>,<Scalar 4>,<Scalar>,<Scalar>...> > <2-Tuple<Scalar 3>,<Scalar 4>>: FALSE, reverse: FALSE
is 57 _ Vectors:
is 58 _ <3-Vector<Scalar 3>,<Scalar 4>,<Scalar 5>> > <3-Tuple<Scalar 3>,<Scalar 4>,<Scalar 5>>: FALSE, reverse: TRUE
is 59 _ <3-Vector<Scalar 3>,<Scalar 4>,<Scalar 5>> > <2-Tuple<Scalar 3>,<Scalar 4>>: FALSE, reverse: FALSE
is 60 _ <3-Vector<Scalar 3>,<Scalar 4>,<Scalar 5>> > <Tuple<Scalar 3>,<Scalar 4>,<Scalar 5>,<Scalar>...>: FALSE, reverse: TRUE
is 61 _ <3-Vector<Scalar 3>,<Scalar 4>,<Scalar 5>> > <3-Tuple<Scalar 3>,<Any>,<Scalar 5>>: FALSE, reverse: TRUE
is 62 _ <Vector<Scalar 3>,<Scalar 4>,<Scalar>...> > <3-Vector<Scalar 3>,<Scalar 4>,<Scalar 5>>: TRUE, reverse: FALSE
is 63 _ <Vector<Scalar 3>,<Scalar 4>,<Scalar>...> > <3-Tuple<Scalar 3>,<Scalar 4>,<Scalar 5>>: FALSE, reverse: FALSE
is 64 _ <Vector<Scalar 3>,<Scalar 4>,<Scalar>...> > <Tuple<Scalar 3>,<Scalar 4>,<Scalar>...>: FALSE, reverse: TRUE
is 65 _ Fields:
is 66 _ <Field <Scalar 3>> > <Field <Any>>: FALSE, reverse: TRUE
is 67 _ <Field <Scalar 3>> > <Field <3-Tuple<Scalar 3>,<3-Tuple<Scalar 3>,<Scalar 4>,<Scalar 5>>,<Scalar 5>>>: FALSE, reverse: FALSE
is 68 _ <Field <3-Tuple<Scalar 3>,<3-Tuple<Scalar 3>,<Scalar 4>,<Scalar 5>>,<Scalar 5>>> > <Field <Any>>: FALSE, reverse: TRUE
is 69 _ <Field <3-Tuple<Scalar 3>,<3-Tuple<Scalar 3>,<Scalar 4>,<Scalar 5>>,<Scalar 5>>> > <Field <3-Tuple<Scalar 3>,<Any>,<Scalar 5>>>: FALSE, reverse: TRUE
is 70 _ Testing least-common-supertype:
is 71 _ LCS ordered pairs:
is 72 _ LCS(<Any>,<Field <Scalar 3>>) = <Any>; inverse match = TRUE
is 73 _ LCS(<Scalar 3>,<Local>) = <Local>; inverse match = TRUE
is 74 _ LCS(<Number>,<Boolean>) = <Number>; inverse match = TRUE
is 75 _ LCS cross-class:
is 76 _ LCS(<Field <3-Tuple<Scalar 3>,<3-Tuple<Scalar 3>,<Scalar 4>,<Scalar 5>>,<Scalar 5>>>,<3-Tuple<Scalar 3>,<3-Tuple<Scalar 3>,<Scalar 4>,<Scalar 5>>,<Scalar 5>>) = <Any>; inverse match = TRUE
is 77 _ LCS(<Boolean false>,<3-Tuple<Scalar 3>,<3-Tuple<Scalar 3>,<Scalar 4>,<Scalar 5>>,<Scalar 5>>) = <Local>; inverse match = TRUE
is 78 _ LCS(<Boolean>,<Vector<Scalar>...>) = <Number>; inverse match = TRUE
is 79 _ LCS(<Boolean true>,<Scalar 5>) = <Scalar>; inverse match = TRUE
is 80 _ LCS(<Vector<Scalar>...>,<3-Tuple<Scalar 3>,<3-Tuple<Scalar 3>,<Scalar 4>,<Scalar 5>>,<Scalar 5>>) = <Tuple<Local>...>; inverse match = TRUE
is 81 _ LCS(<Boolean>,<Lambda>) = <Local>; inverse match = TRUE
is 82 _ LCS(<Vector<Scalar>...>,<Field <Any>>) = <Any>; inverse match = TRUE
is 83 _ LCS in-class generalization:
is 84 _ LCS(<Boolean false>,<Boolean true>) = <Boolean>; inverse match = TRUE
is 85 _ LCS(<Boolean true>,<Scalar 1>) = <Scalar 1>; inverse match = TRUE
is 86 _ LCS(<Scalar 1>,<Scalar 3>) = <Scalar>; inverse match = TRUE
is 87 _ LCS(<2-Tuple<Scalar 3>,<Scalar 1>>,<3-Tuple<Scalar 3>,<Scalar 4>,<Scalar 5>>) = <Tuple<Scalar 3>,<Scalar>,<Scalar 5>...>; inverse match = TRUE
is 88 _ LCS(<Tuple<Scalar 3>,<Scalar 4>,<Scalar 5>,<Scalar>...>,<3-Tuple<Scalar 3>,<Any>,<Scalar 5>>) = <Tuple<Scalar 3>,<Any>,<Scalar 5>,<Scalar>...>; inverse match = TRUE
is 89 _ LCS(<3-Tuple<Scalar 3>,<3-Tuple<Scalar 3>,<Scalar 4>,<Scalar 5>>,<Scalar 5>>,<3-Tuple<Scalar 3>,<Scalar 4>,<Scalar 5>>) = <3-Tuple<Scalar 3>,<Local>,<Scalar 5>>; inverse match = TRUE
is 90 _ LCS(<Tuple<Scalar 3>,<Scalar 4>,<Scalar>,<Scalar>...>,<2-Tuple<Scalar 3>,<Scalar 4>>) = <Tuple<Scalar 3>,<Scalar 4>,<Scalar>...>; inverse match = TRUE
is 91 _ LCS(<Vector<Scalar 3>,<Scalar 4>,<Scalar>...>,<3-Vector<Scalar 1>,<Scalar 4>,<Scalar 5>>) = <Vector<Scalar>,<Scalar 4>,<Scalar>...>; inverse match = TRUE
is 92 _ LCS(<3-Vector<Scalar 1>,<Scalar 4>,<Scalar 5>>,<Scalar 3>) = <Number>; inverse match = TRUE
is 93 _ LCS(<3-Vector<Scalar 1>,<Scalar 4>,<Scalar 5>>,<3-Tuple<Scalar 3>,<Scalar 4>,<Scalar 5>>) = <3-Tuple<Scalar>,<Scalar 4>,<Scalar 5>>; inverse match = TRUE
is 94 _ LCS(<Symbol foo>,<Symbol bar>) = <Symbol>; inverse match = TRUE
is 95 _ LCS(<Field <Scalar 3>>,<Field <3-Tuple<Scalar 3>,<3-Tuple<Scalar 3>,<Scalar 4>,<Scalar 5>>,<Scalar 5>>>) = <Field <Local>>; inverse match = TRUE
is 96 _ Testing greatest-common-subtype:
is 97 _ GCS ordered pairs:
is 98 _ GCS(<Any>,<Field <Scalar 3>>) = <Field <Scalar 3>>; inverse match = TRUE
is 99 _ GCS(<Scalar 3>,<Local>) = <Scalar 3>; inverse match = TRUE
is 100 _ GCS(<Number>,<Boolean>) = <Boolean>; inverse match = TRUE
is 101 _ GCS cross-class:
is 102 _ GCS(<Field <3-Tuple<Scalar 3>,<3-Tuple<Scalar 3>,<Scalar 4>,<Scalar 5>>,<Scalar 5>>>,<3-Tuple<Scalar 3>,<3-Tuple<Scalar 3>,<Scalar 4>,<Scalar 5>>,<Scalar 5>>) = NULL; inverse match = TRUE
is 103 _ GCS(<Vector<Scalar>...>,<3-Tuple<Scalar 3>,<3-Tuple<Scalar 3>,<Scalar 4>,<Scalar 5>>,<Scalar 5>>) = NULL; inverse match = TRUE
is 104 _ GCS(<Boolean>,<Lambda>) = NULL; inverse match = TRUE
is 105 _ GCS(<Vector<Scalar>...>,<Field <Any>>) = NULL; inverse match = TRUE
is 106 _ GCS(<Number>,<Tuple<Any>...>) = <Vector<Scalar>...>; inverse match = TRUE
is 107 _ GCS(<3-Tuple<Scalar 3>,<3-Tuple<Scalar 3>,<Scalar 4>,<Scalar 5>>,<Scalar 5>>,<Number>) = NULL; inverse match = TRUE
is 108 _ GCS(<3-Tuple<Scalar 3>,<Any>,<Scalar 5>>,<Number>) = <3-Vector<Scalar 3>,<Scalar>,<Scalar 5>>; inverse match = TRUE
is 109 _ GCS in-class specialization:
is 110 _ GCS(<Boolean false>,<Boolean true>) = NULL; inverse match = TRUE
is 111 _ GCS(<Boolean true>,<Scalar 1>) = <Boolean true>; inverse match = TRUE
is 112 _ GCS(<Scalar 1>,<Scalar 3>) = NULL; inverse match = TRUE
is 113 _ GCS(<2-Tuple<Scalar 3>,<Scalar 4>>,<3-Tuple<Scalar 3>,<Scalar 4>,<Scalar 5>>) = NULL; inverse match = TRUE
is 114 _ GCS(<2-Tuple<Scalar 3>,<Scalar 4>>,<Tuple<Scalar 3>,<Scalar 4>,<Scalar>...>) = <2-Tuple<Scalar 3>,<Scalar 4>>; inverse match = TRUE
is 115 _ GCS(<2-Tuple<Scalar 3>,<Scalar 4>>,<Tuple<Scalar 3>,<Scalar 4>,<Scalar>,<Scalar>...>) = NULL; inverse match = TRUE
is 116 _ GCS(<Tuple<Scalar 3>,<Scalar 4>,<Scalar 5>,<Scalar>...>,<3-Tuple<Scalar 3>,<Any>,<Scalar 5>>) = <3-Tuple<Scalar 3>,<Scalar 4>,<Scalar 5>>; inverse match = TRUE
is 117 _ GCS(<Tuple<Scalar 3>,<Scalar 4>,<Any>...>,<Tuple<Scalar 3>,<Scalar 4>,<Scalar>,<Scalar>...>) = <Tuple<Scalar 3>,<Scalar 4>,<Scalar>,<Scalar>...>; inverse match = TRUE
is 118 _ GCS(<3-Tuple<Scalar 3>,<Any>,<Scalar 5>>,<Tuple<Scalar 3>,<Scalar 4>,<Any>...>) = <3-Tuple<Scalar 3>,<Scalar 4>,<Scalar 5>>; inverse match = TRUE
is 119 _ GCS(<Tuple<Scalar 3>,<Any>,<Scalar 5>,<Scalar>...>,<Tuple<Scalar 3>,<Scalar 4>,<Any>...>) = <Tuple<Scalar 3>,<Scalar 4>,<Scalar 5>,<Scalar>...>; inverse match = TRUE
is 120 _ GCS(<Tuple<Scalar 3>,<Any>,<Scalar 5>,<Scalar>...>,<Tuple<Scalar 3>,<Any>,<Scalar 5>,<Field <Any>>...>) = NULL; inverse match = TRUE
is 121 _ GCS(<Tuple<Scalar 3>,<Any>,<Scalar 5>,<Field <Any>>...>,<Tuple<Scalar 3>,<Scalar 4>,<Any>...>) = <Tuple<Scalar 3>,<Scalar 4>,<Scalar 5>,<Field <Any>>...>; inverse match = TRUE
is 122 _ GCS(<Vector<Scalar 3>,<Scalar 4>,<Scalar>...>,<3-Tuple<Scalar 3>,<Any>,<Scalar 5>>) = <3-Vector<Scalar 3>,<Scalar 4>,<Scalar 5>>; inverse match = TRUE
is 123 _ GCS(<3-Tuple<Scalar 3>,<Any>,<Scalar 5>>,<Vector<Scalar 3>,<Scalar 4>,<Scalar>...>) = <3-Vector<Scalar 3>,<Scalar 4>,<Scalar 5>>; inverse match = TRUE
is 124 _ GCS(<Vector<Scalar 3>,<Scalar 4>,<Scalar>...>,<3-Vector<Scalar>,<Scalar 4>,<Scalar 5>>) = <3-Vector<Scalar 3>,<Scalar 4>,<Scalar 5>>; inverse match = TRUE
is 125 _ GCS(<Symbol foo>,<Symbol bar>) = NULL; inverse match = TRUE
is 126 _ GCS(<Field <3-Tuple<Scalar 3>,<Any>,<Scalar 5>>>,<Field <3-Tuple<Scalar 3>,<3-Tuple<Scalar 3>,<Scalar 4>,<Scalar 5>>,<Scalar 5>>>) = <Field <3-Tuple<Scalar 3>,<3-Tuple<Scalar 3>,<Scalar 4>,<Scalar 5>>,<Scalar 5>>>; inverse match = TRUE


test: $(P2B) -CDall '(+ ,) zeros 3 4, `)'
is 0 _ command-line:1: Wrapper macro comma is not applied to anything
is 1 _ command-line:1: Missing right parenthesis
is 2 _ Compilation failed.

test: $(P2B) -CDall '3'
is 0 _ Amorphous Mediums:
is 1 _ [Medium: Alfa = root]
is 2 _ Fields:
is 3 _   Bravo: Alfa --> <Scalar 3> OUTPUT
is 4 _ Operator Instances:
is 5 _   [Lit: <Scalar 3>] --> Bravo<Scalar 3> OUTPUT
is 6 _ Amorphous Mediums:
is 7 _   [Medium: Alfa = root]
is 8 _ Fields:
is 9 _   Bravo: Alfa --> <Scalar 3> OUTPUT
is 10 _ Operator Instances:
is 11 _   [Lit: <Scalar 3>] --> Bravo<Scalar 3> OUTPUT

test: $(P2B) -CDanalyzed '-1.7'
is 0 _ Amorphous Mediums:
is 1 _   [Medium: Alfa = root]
is 2 _ Fields:
is 3 _   Bravo: Alfa --> <Scalar -1.7> OUTPUT
is 4 _ Operator Instances:
is 5 _   [Lit: <Scalar -1.7>] --> Bravo<Scalar -1.7> OUTPUT

test: $(P2B) -CDanalyzed "0.09e-4"
is 0 _ Amorphous Mediums:
is 1 _   [Medium: Alfa = root]
is 2 _ Fields:
is 3 _   Bravo: Alfa --> <Scalar 9e-06> OUTPUT
is 4 _ Operator Instances:
is 5 _   [Lit: <Scalar 9e-06>] --> Bravo<Scalar 9e-06> OUTPUT

test: $(P2B) -CDall "(+ 3 4)"
is 0 _ Amorphous Mediums:
is 1 _   [Medium: Alfa = root]
is 2 _ Fields:
is 3 _   Bravo: Alfa --> <Number> OUTPUT
is 4 _   Charlie: Alfa --> <Scalar 3>
is 5 _   Delta: Alfa --> <Scalar 4>
is 6 _ Operator Instances:
is 7 _   Charlie<Scalar 3>, Delta<Scalar 4> --> [+] --> Bravo<Number> OUTPUT
is 8 _   [Lit: <Scalar 3>] --> Charlie<Scalar 3>
is 9 _   [Lit: <Scalar 4>] --> Delta<Scalar 4>
is 10 _ Amorphous Mediums:
is 11 _   [Medium: Alfa = root]
is 12 _ Fields:
is 13 _   Echo: Alfa --> <Scalar 7> OUTPUT
is 14 _ Operator Instances:
is 15 _   [Lit: <Scalar 7>] --> Echo<Scalar 7> OUTPUT

test: $(P2B) -CDall "(foo 3 4)" 
is 0 _ Error during interpretation:
is 1 _ command-line:1 Error: Couldn't find definition of Operator foo
is 2 _ Compilation failed.

test: $(P2B) -CDall "(2 3 4)"
is 0 _ Error during interpretation:
is 1 _ command-line:1 Error: 2 is not an Operator
is 2 _ Compilation failed.

test: $(P2B) -CDall "(+ 1 (+ (+ 2 3) (+ 4)) 5)"
is 0 _ Amorphous Mediums:
is 1 _   [Medium: Alfa = root]
is 2 _ Fields:
is 3 _   Bravo: Alfa --> <Number> OUTPUT
is 4 _   Charlie: Alfa --> <Scalar 1>
is 5 _   Delta: Alfa --> <Number>
is 6 _   Echo: Alfa --> <Number>
is 7 _   Foxtrot: Alfa --> <Scalar 2>
is 8 _   Golf: Alfa --> <Scalar 3>
is 9 _   Hotel: Alfa --> <Number>
is 10 _   India: Alfa --> <Scalar 4>
is 11 _   Juliet: Alfa --> <Scalar 5>
is 12 _ Operator Instances:
is 13 _   Charlie<Scalar 1>, Delta<Number>, Juliet<Scalar 5> --> [+] --> Bravo<Number> OUTPUT
is 14 _   [Lit: <Scalar 1>] --> Charlie<Scalar 1>
is 15 _   Echo<Number>, Hotel<Number> --> [+] --> Delta<Number>
is 16 _   Foxtrot<Scalar 2>, Golf<Scalar 3> --> [+] --> Echo<Number>
is 17 _   [Lit: <Scalar 2>] --> Foxtrot<Scalar 2>
is 18 _   [Lit: <Scalar 3>] --> Golf<Scalar 3>
is 19 _   India<Scalar 4> --> [+] --> Hotel<Number>
is 20 _   [Lit: <Scalar 4>] --> India<Scalar 4>
is 21 _   [Lit: <Scalar 5>] --> Juliet<Scalar 5>
is 22 _ Amorphous Mediums:
is 23 _   [Medium: Alfa = root]
is 24 _ Fields:
is 25 _   Kilo: Alfa --> <Scalar 15> OUTPUT
is 26 _ Operator Instances:
is 27 _   [Lit: <Scalar 15>] --> Kilo<Scalar 15> OUTPUT

test: $(P2B) -CDall "(let ((x 3) (y 4)) (+ x y))"
is 0 _ Amorphous Mediums:
is 1 _   [Medium: Alfa = root]
is 2 _ Fields:
is 3 _   Bravo: Alfa --> <Scalar 3>
is 4 _   Charlie: Alfa --> <Scalar 4>
is 5 _   Delta: Alfa --> <Number> OUTPUT
is 6 _ Operator Instances:
is 7 _   [Lit: <Scalar 3>] --> Bravo<Scalar 3>
is 8 _   [Lit: <Scalar 4>] --> Charlie<Scalar 4>
is 9 _   Bravo<Scalar 3>, Charlie<Scalar 4> --> [+] --> Delta<Number> OUTPUT

test: $(P2B) -CDall "(let () 2 3 4)"
is 0 _ Amorphous Mediums:
is 1 _   [Medium: Alfa = root]
is 2 _ Fields:
is 3 _   Bravo: Alfa --> <Scalar 2>
is 4 _   Charlie: Alfa --> <Scalar 3>
is 5 _   Delta: Alfa --> <Scalar 4> OUTPUT
is 6 _ Operator Instances:
is 7 _   [Lit: <Scalar 2>] --> Bravo<Scalar 2>
is 8 _   [Lit: <Scalar 3>] --> Charlie<Scalar 3>
is 9 _   [Lit: <Scalar 4>] --> Delta<Scalar 4> OUTPUT

test: $(P2B) -CDall "(let (a (3 4) (() 5) (b 6 7)) x)"
is 0 _ Error during interpretation:
is 1 _ command-line:1 Error: Malformed let statement: a
is 2 _ command-line:1 Error: Malformed let statement: (3 4)
is 3 _ command-line:1 Error: Malformed let statement: (() 5)
is 4 _ command-line:1 Error: Malformed let statement: (b 6 7)
is 5 _ command-line:1 Error: Couldn't find definition of x
is 6 _ Compilation failed.

test: $(P2B) -CDall "(let ((x 3)))"
is 0 _ Error during interpretation:
is 1 _ command-line:1 Error: Malformed let statement: (let ((x 3)))
is 2 _ Compilation failed.

test: $(P2B) -CDall "(let 2 3)"
is 0 _ Error during interpretation:
is 1 _ command-line:1 Error: Malformed let statement: (let 2 3)
is 2 _ Compilation failed.

test: $(P2B) -CDall "(let ((x 5)) (let ((y 2)) (+ x x y)))"
is 0 _ Amorphous Mediums:
is 1 _   [Medium: Alfa = root]
is 2 _ Fields:
is 3 _   Bravo: Alfa --> <Scalar 5>
is 4 _   Charlie: Alfa --> <Scalar 2>
is 5 _   Delta: Alfa --> <Number> OUTPUT
is 6 _ Operator Instances:
is 7 _   [Lit: <Scalar 5>] --> Bravo<Scalar 5>
is 8 _   [Lit: <Scalar 2>] --> Charlie<Scalar 2>
is 9 _   Bravo<Scalar 5>, Bravo<Scalar 5>, Charlie<Scalar 2> --> [+] --> Delta<Number> OUTPUT

test: $(P2B) -CDall "(restrict 1 (+ 3 4))"
is 0 _ Amorphous Mediums:
is 1 _   [Medium: Alfa = root]
is 2 _   [Medium: Bravo = Alfa | Charlie]
is 3 _ Fields:
is 4 _   Charlie: Alfa --> <Scalar 1>
is 5 _   Delta: Bravo --> <Number> OUTPUT
is 6 _   Echo: Bravo --> <Scalar 3>
is 7 _   Foxtrot: Bravo --> <Scalar 4>
is 8 _ Operator Instances:
is 9 _   [Lit: <Scalar 1>] --> Charlie<Scalar 1>
is 10 _   Echo<Scalar 3>, Foxtrot<Scalar 4> --> [+] --> Delta<Number> OUTPUT
is 11 _   [Lit: <Scalar 3>] --> Echo<Scalar 3>
is 12 _   [Lit: <Scalar 4>] --> Foxtrot<Scalar 4>

test: $(P2B) -CDall "(let ((x 3)) (restrict 0 x))"
is 0 _ Amorphous Mediums:
is 1 _   [Medium: Alfa = root]
is 2 _   [Medium: Bravo = Alfa | Charlie]
is 3 _ Fields:
is 4 _   Delta: Alfa --> <Scalar 3>
is 5 _   Charlie: Alfa --> <Scalar 0>
is 6 _   Echo: Bravo --> <Any> OUTPUT
is 7 _ Operator Instances:
is 8 _   [Lit: <Scalar 3>] --> Delta<Scalar 3>
is 9 _   [Lit: <Scalar 0>] --> Charlie<Scalar 0>
is 10 _   Charlie<Scalar 0>, Delta<Scalar 3> --> [restrict] --> Echo<Any> OUTPUT

test: $(P2B) -CDall "(def x 3) (+ x 4)"
is 0 _ Amorphous Mediums:
is 1 _   [Medium: Alfa = root]
is 2 _ Fields:
is 3 _   Bravo: Alfa --> <Scalar 3>
is 4 _   Charlie: Alfa --> <Number> OUTPUT
is 5 _   Delta: Alfa --> <Scalar 4>
is 6 _ Operator Instances:
is 7 _   [Lit: <Scalar 3>] --> Bravo<Scalar 3>
is 8 _   Bravo<Scalar 3>, Delta<Scalar 4> --> [+] --> Charlie<Number> OUTPUT
is 9 _   [Lit: <Scalar 4>] --> Delta<Scalar 4>

// tests lambda types & simplification of apply
test: $(P2B) -CDall "(apply * (apply + 3 4) (mid))"
is 0 _ Amorphous Mediums:
is 1 _   [Medium: Alfa = root]
is 2 _ Fields:
is 3 _   Bravo: Alfa --> <ANY> OUTPUT
is 4 _   Charlie: Alfa --> <Lambda [*]>
is 5 _   Delta: Alfa --> <ANY>
is 6 _   Echo: Alfa --> <Lambda [+]>
is 7 _   Foxtrot: Alfa --> <Scalar 3>
is 8 _   Golf: Alfa --> <Scalar 4>
is 9 _   Hotel: Alfa --> <Scalar>
is 10 _ Operator Instances:
is 11 _   Charlie<Lambda [*]>, Delta<ANY>, Hotel<Scalar> --> [apply] --> Bravo<ANY> OUTPUT
is 12 _   [Lit: <Lambda [*]>] --> Charlie<Lambda [*]>
is 13 _   Echo<Lambda [+]>, Foxtrot<Scalar 3>, Golf<Scalar 4> --> [apply] --> Delta<ANY>
is 14 _   [Lit: <Lambda [+]>] --> Echo<Lambda [+]>
is 15 _   [Lit: <Scalar 3>] --> Foxtrot<Scalar 3>
is 16 _   [Lit: <Scalar 4>] --> Golf<Scalar 4>
is 17 _   [mid] --> Hotel<Scalar>
is 18 _ Amorphous Mediums:
is 19 _   [Medium: Alfa = root]
is 20 _ Fields:
is 21 _   Hotel: Alfa --> <Scalar>
is 22 _   India: Alfa --> <Scalar> OUTPUT
is 23 _   Juliet: Alfa --> <Scalar 7>
is 24 _ Operator Instances:
is 25 _   [mid] --> Hotel<Scalar>
is 26 _   Juliet<Scalar 7>, Hotel<Scalar> --> [*] --> India<Scalar> OUTPUT
is 27 _   [Lit: <Scalar 7>] --> Juliet<Scalar 7>

test: $(P2B) -CDall "((lambda () (+ 2 3)))"
is 0 _ Function: lambda~4 [Signature:  --> <D:return>] called 1 times
is 1 _   Amorphous Mediums:
is 2 _     [Medium: Alfa = root]
is 3 _   Fields:
is 4 _     Bravo: Alfa --> <Number> OUTPUT
is 5 _     Charlie: Alfa --> <Scalar 2>
is 6 _     Delta: Alfa --> <Scalar 3>
is 7 _   Operator Instances:
is 8 _     Charlie<Scalar 2>, Delta<Scalar 3> --> [+] --> Bravo<Number> OUTPUT
is 9 _     [Lit: <Scalar 2>] --> Charlie<Scalar 2>
is 10 _     [Lit: <Scalar 3>] --> Delta<Scalar 3>
is 11 _ Amorphous Mediums:
is 12 _   [Medium: Echo = root]
is 13 _ Fields:
is 14 _   Foxtrot: Echo --> <D:return> OUTPUT
is 15 _ Operator Instances:
is 16 _   [Fun: lambda~4] --> Foxtrot<D:return> OUTPUT

test: $(P2B) -CDall "(def double (x|scalar) (+ x x)) (double (double 3))" --function-inlining-threshold 0
is 0 _ Function: double [Signature: <Scalar> --> <D:return>] called 2 times
is 1 _   Amorphous Mediums:
is 2 _     [Medium: Alfa = root]
is 3 _   Fields:
is 4 _     Bravo: Alfa --> <Scalar>
is 5 _     Charlie: Alfa --> <Number> OUTPUT
is 6 _   Operator Instances:
is 7 _     [Parameter 0: x] --> Bravo<Scalar>
is 8 _     Bravo<Scalar>, Bravo<Scalar> --> [+] --> Charlie<Number> OUTPUT
is 9 _ Amorphous Mediums:
is 10 _   [Medium: Delta = root]
is 11 _ Fields:
is 12 _   Echo: Delta --> <D:return> OUTPUT
is 13 _   Foxtrot: Delta --> <D:return>
is 14 _   Golf: Delta --> <Scalar 3>
is 15 _ Operator Instances:
is 16 _   Foxtrot<D:return> --> [Fun: double] --> Echo<D:return> OUTPUT
is 17 _   Golf<Scalar 3> --> [Fun: double] --> Foxtrot<D:return>
is 18 _   [Lit: <Scalar 3>] --> Golf<Scalar 3>

test: $(P2B) -CDall "(def froz (x &optional y) (+ x (mid))) (- (froz) (froz 1 2 3) (sin 2 3))"
is 0 _ Error during interpretation:
is 1 _ command-line:1 Error: Called [Fun: froz] with 0 arguments; it requires from 1 to 2
is 2 _ command-line:1 Error: Called [Fun: froz] with 3 arguments; it requires from 1 to 2
is 3 _ command-line:1 Error: Called [sin] with 2 arguments; it requires exactly 1
is 4 _ Compilation failed.

test: $(P2B) -CDall "(def fooloop (y) (+ y (restrict (> y 0) (fooloop (+ y -1))))) (fooloop 3)" --function-inlining-threshold 2
is 0 _ Function: fooloop [Signature: <Any> --> <D:return>] called 2 times
is 1 _   Amorphous Mediums:
is 2 _     [Medium: Alfa = root]
is 3 _     [Medium: Bravo = Alfa | Charlie]
is 4 _   Fields:
is 5 _     Delta: Alfa --> <Any>
is 6 _     Echo: Alfa --> <Number> OUTPUT
is 7 _     Charlie: Alfa --> <Boolean>
is 8 _     Foxtrot: Alfa --> <Scalar 0>
is 9 _     Golf: Bravo --> <D:return>
is 10 _     Hotel: Bravo --> <Number>
is 11 _     India: Bravo --> <Any>
is 12 _     Juliet: Bravo --> <Scalar -1>
is 13 _   Operator Instances:
is 14 _     [Parameter 0: y] --> Delta<Any>
is 15 _     Delta<Any>, Golf<D:return> --> [+] --> Echo<Number> OUTPUT
is 16 _     Delta<Any>, Foxtrot<Scalar 0> --> [>] --> Charlie<Boolean>
is 17 _     [Lit: <Scalar 0>] --> Foxtrot<Scalar 0>
is 18 _     Hotel<Number> --> [Fun: fooloop] --> Golf<D:return>
is 19 _     India<Any>, Juliet<Scalar -1> --> [+] --> Hotel<Number>
is 20 _     Charlie<Boolean>, Delta<Any> --> [restrict] --> India<Any>
is 21 _     [Lit: <Scalar -1>] --> Juliet<Scalar -1>
is 22 _ Amorphous Mediums:
is 23 _   [Medium: Kilo = root]
is 24 _ Fields:
is 25 _   Lima: Kilo --> <D:return> OUTPUT
is 26 _   Mike: Kilo --> <Scalar 3>
is 27 _ Operator Instances:
is 28 _   Mike<Scalar 3> --> [Fun: fooloop] --> Lima<D:return> OUTPUT
is 29 _   [Lit: <Scalar 3>] --> Mike<Scalar 3>
is 30 _ Function: fooloop [Signature: <Any> --> <D:return>] called 2 times

test: $(P2B) -CDall "(let ((x 3) (x 4)) x)"
is 0 _ Error during interpretation:
is 1 _ command-line:1 Error: Cannot bind 'x': already bound
is 2 _ Compilation failed.

test: $(P2B) -CDall "(def foo 3) (def foo 4) foo"
is 0 _ Amorphous Mediums:
is 1 _   [Medium: Alfa = root]
is 2 _ Fields:
is 3 _   Bravo: Alfa --> <Scalar 3>
is 4 _   Charlie: Alfa --> <Scalar 4> OUTPUT
is 5 _ Operator Instances:
is 6 _   [Lit: <Scalar 3>] --> Bravo<Scalar 3>
is 7 _   [Lit: <Scalar 4>] --> Charlie<Scalar 4> OUTPUT

test: $(P2B) -CDall "(let ((restrict 3) (all 4) (let 5)) 6)"
is 0 _ Error during interpretation:
is 1 _ command-line:1 Error: Cannot bind 'restrict': symbol is reserved
is 2 _ command-line:1 Error: Cannot bind 'all': symbol is reserved
is 3 _ command-line:1 Error: Cannot bind 'let': symbol is reserved
is 4 _ Compilation failed.

test: $(P2B) -CDall "(lambda (y y) y)"
is 0 _ Error during interpretation:
is 1 _ command-line:1 Error: Cannot bind 'y': already bound
is 2 _ Compilation failed.

test: $(P2B) -CDall "(lambda (x 3) 4)"
is 0 _ Error during interpretation:
is 1 _ command-line:1 Error: Parameter name not a symbol: 3
is 2 _ Compilation failed.

test: $(P2B) -CDall "(lambda x 4)"
is 0 _ Error during interpretation:
is 1 _ command-line:1 Error: Signature not a list: x
is 2 _ Compilation failed.

test: $(P2B) -CDall "(lambda (&rest x y) 4)"
is 0 _ Error during interpretation:
is 1 _ command-line:1 Error: No signature past '&rest' variable: (&rest x y)
is 2 _ Compilation failed.

test: $(P2B) -CDall "(+ NaN -Inf inf pi e)"
is 0 _ Amorphous Mediums:
is 1 _   [Medium: Alfa = root]
is 2 _ Fields:
is 3 _   Bravo: Alfa --> <Number> OUTPUT
is 4 _   Charlie: Alfa --> <Scalar nan>
is 5 _   Delta: Alfa --> <Scalar -inf>
is 6 _   Echo: Alfa --> <Scalar inf>
is 7 _   Foxtrot: Alfa --> <Scalar 3.14159>
is 8 _   Golf: Alfa --> <Scalar 2.71828>
is 9 _ Operator Instances:
is 10 _   Charlie<Scalar nan>, Delta<Scalar -inf>, Echo<Scalar inf>, Foxtrot<Scalar 3.14159>, Golf<Scalar 2.71828> --> [+] --> Bravo<Number> OUTPUT
is 11 _   [Lit: <Scalar nan>] --> Charlie<Scalar nan>
is 12 _   [Lit: <Scalar -inf>] --> Delta<Scalar -inf>
is 13 _   [Lit: <Scalar inf>] --> Echo<Scalar inf>
is 14 _   [Lit: <Scalar 3.14159>] --> Foxtrot<Scalar 3.14159>
is 15 _   [Lit: <Scalar 2.71828>] --> Golf<Scalar 2.71828>
is 16 _ Amorphous Mediums:
is 17 _   [Medium: Alfa = root]
is 18 _ Fields:
is 19 _   Hotel: Alfa --> <Scalar nan> OUTPUT
is 20 _ Operator Instances:
is 21 _   [Lit: <Scalar nan>] --> Hotel<Scalar nan> OUTPUT

test: $(P2B) -CDall "(xor true false)"
is 0 _ Function: xor [Signature: <Any> <Any> --> <D:return>] called 1 times
is 1 _   Amorphous Mediums:
is 2 _     [Medium: Alfa = root]
is 3 _   Fields:
is 4 _     Bravo: Alfa --> <Any>
is 5 _     Charlie: Alfa --> <Any>
is 6 _     Delta: Alfa --> <Any> OUTPUT
is 7 _     Echo: Alfa --> <Boolean>
is 8 _   Operator Instances:
is 9 _     [Parameter 0: x] --> Bravo<Any>
is 10 _     [Parameter 1: y] --> Charlie<Any>
is 11 _     Bravo<Any>, Echo<Boolean>, Charlie<Any> --> [mux] --> Delta<Any> OUTPUT
is 12 _     Charlie<Any> --> [not] --> Echo<Boolean>
is 13 _ Amorphous Mediums:
is 14 _   [Medium: Foxtrot = root]
is 15 _ Fields:
is 16 _   Golf: Foxtrot --> <D:return> OUTPUT
is 17 _   Hotel: Foxtrot --> <Boolean true>
is 18 _   India: Foxtrot --> <Boolean false>
is 19 _ Operator Instances:
is 20 _   Hotel<Boolean true>, India<Boolean false> --> [Fun: xor] --> Golf<D:return> OUTPUT
is 21 _   [Lit: <Boolean true>] --> Hotel<Boolean true>
is 22 _   [Lit: <Boolean false>] --> India<Boolean false>
is 23 _ Amorphous Mediums:
is 24 _   [Medium: Foxtrot = root]
is 25 _ Fields:
is 26 _   Juliet: Foxtrot --> <Boolean true> OUTPUT
is 27 _ Operator Instances:
is 28 _   [Lit: <Boolean true>] --> Juliet<Boolean true> OUTPUT
is 29 _ Stopping before localization

// Make sure that extra function calls are ignored by "relevant" count
test: $(P2B) "(def foo () (mid)) (def bar () (* (foo) (foo))) (foo)" -CDanalyzed --function-inlining-threshold 0
is 0 _ Function: foo [Signature:  --> <D:return>] called 1 times
is 1 _   Amorphous Mediums:
is 2 _     [Medium: Alfa = root]
is 3 _   Fields:
is 4 _     Bravo: Alfa --> <Scalar> OUTPUT
is 5 _   Operator Instances:
is 6 _     [mid] --> Bravo<Scalar> OUTPUT
is 7 _ Amorphous Mediums:
is 8 _   [Medium: Charlie = root]
is 9 _ Fields:
is 10 _   Delta: Charlie --> <Scalar> OUTPUT
is 11 _ Operator Instances:
is 12 _   [Fun: foo] --> Delta<Scalar> OUTPUT

test: $(P2B) -CDall "(let ((a 3) (b (+ a 1)) (c (+ a b))) c)"
is 0 _ Error during interpretation:
is 1 _ command-line:1 Error: Couldn't find definition of a
is 2 _ command-line:1 Error: Couldn't find definition of a
is 3 _ command-line:1 Error: Couldn't find definition of b
is 4 _ Compilation failed.

test: $(P2B) -CDall "(let* ((a 3) (b (+ a 1)) (c (+ a b))) c)"
is 0 _ Amorphous Mediums:
is 1 _   [Medium: Alfa = root]
is 2 _ Fields:
is 3 _   Bravo: Alfa --> <Scalar 3>
is 4 _   Charlie: Alfa --> <Number>
is 5 _   Delta: Alfa --> <Scalar 1>
is 6 _   Echo: Alfa --> <Number> OUTPUT
is 7 _ Operator Instances:
is 8 _   [Lit: <Scalar 3>] --> Bravo<Scalar 3>
is 9 _   Bravo<Scalar 3>, Delta<Scalar 1> --> [+] --> Charlie<Number>
is 10 _   [Lit: <Scalar 1>] --> Delta<Scalar 1>
is 11 _   Bravo<Scalar 3>, Charlie<Number> --> [+] --> Echo<Number> OUTPUT

test: $(P2B) -CDall "(macro foo (x y) (+ ,x ,y ,x)) (foo 3 4)" 
is 0 _ Amorphous Mediums:
is 1 _   [Medium: Alfa = root]
is 2 _ Fields:
is 3 _   Bravo: Alfa --> <Number> OUTPUT
is 4 _   Charlie: Alfa --> <Scalar 3>
is 5 _   Delta: Alfa --> <Scalar 4>
is 6 _   Echo: Alfa --> <Scalar 3>
is 7 _ Operator Instances:
is 8 _   Charlie<Scalar 3>, Delta<Scalar 4>, Echo<Scalar 3> --> [+] --> Bravo<Number> OUTPUT
is 9 _   [Lit: <Scalar 3>] --> Charlie<Scalar 3>
is 10 _   [Lit: <Scalar 4>] --> Delta<Scalar 4>
is 11 _   [Lit: <Scalar 3>] --> Echo<Scalar 3>

test: $(P2B) -CDall "(macro foo (x y) (+ ,x ,y ,z)) (foo 3 4)"
is 0 _ Error during interpretation:
is 1 _ command-line:1 Error: Couldn't find definition of SExpr z
is 2 _ command-line:1 Error: Macro expansion failed on (foo 3 4)
is 3 _ Compilation failed.

test: $(P2B) -CDall "(macro foo (x) (+ 2 ,@x)) (foo (4 5))" 
is 0 _ Amorphous Mediums:
is 1 _   [Medium: Alfa = root]
is 2 _ Fields:
is 3 _   Bravo: Alfa --> <Number> OUTPUT
is 4 _   Charlie: Alfa --> <Scalar 2>
is 5 _   Delta: Alfa --> <Scalar 4>
is 6 _   Echo: Alfa --> <Scalar 5>
is 7 _ Operator Instances:
is 8 _   Charlie<Scalar 2>, Delta<Scalar 4>, Echo<Scalar 5> --> [+] --> Bravo<Number> OUTPUT
is 9 _   [Lit: <Scalar 2>] --> Charlie<Scalar 2>
is 10 _   [Lit: <Scalar 4>] --> Delta<Scalar 4>
is 11 _   [Lit: <Scalar 5>] --> Echo<Scalar 5>

test: $(P2B) -CDall "(macro foo (x) (let ((?x ,x)) (+ ?x ?x))) (foo 3)"
is 0 _ Amorphous Mediums:
is 1 _   [Medium: Alfa = root]
is 2 _ Fields:
is 3 _   Bravo: Alfa --> <Scalar 3>
is 4 _   Charlie: Alfa --> <Number> OUTPUT
is 5 _ Operator Instances:
is 6 _   [Lit: <Scalar 3>] --> Bravo<Scalar 3>
is 7 _   Bravo<Scalar 3>, Bravo<Scalar 3> --> [+] --> Charlie<Number> OUTPUT

test: $(P2B) -CDall "(if 2 3 4)"
is 0 _ Amorphous Mediums:
is 1 _   [Medium: Alfa = root]
is 2 _   [Medium: Bravo = Alfa | Charlie]
is 3 _   [Medium: Delta = Alfa | Echo]
is 4 _ Fields:
is 5 _   Charlie: Alfa --> <Scalar 2>
is 6 _   Foxtrot: Alfa --> <Any> OUTPUT
is 7 _   Golf: Bravo --> <Scalar 3>
is 8 _   Echo: Alfa --> <Boolean>
is 9 _   Hotel: Delta --> <Scalar 4>
is 10 _ Operator Instances:
is 11 _   [Lit: <Scalar 2>] --> Charlie<Scalar 2>
is 12 _   Charlie<Scalar 2>, Golf<Scalar 3>, Hotel<Scalar 4> --> [mux] --> Foxtrot<Any> OUTPUT
is 13 _   [Lit: <Scalar 3>] --> Golf<Scalar 3>
is 14 _   Charlie<Scalar 2> --> [not] --> Echo<Boolean>
is 15 _   [Lit: <Scalar 4>] --> Hotel<Scalar 4>

test: $(P2B) -CDall "(macro addpi (x) (+ ,@x pi)) (macro dup2 (x) (addpi (,x ,x))) (dup2 5)"
is 0 _ Amorphous Mediums:
is 1 _   [Medium: Alfa = root]
is 2 _ Fields:
is 3 _   Bravo: Alfa --> <Number> OUTPUT
is 4 _   Charlie: Alfa --> <Scalar 5>
is 5 _   Delta: Alfa --> <Scalar 5>
is 6 _   Echo: Alfa --> <Scalar 3.14159>
is 7 _ Operator Instances:
is 8 _   Charlie<Scalar 5>, Delta<Scalar 5>, Echo<Scalar 3.14159> --> [+] --> Bravo<Number> OUTPUT
is 9 _   [Lit: <Scalar 5>] --> Charlie<Scalar 5>
is 10 _   [Lit: <Scalar 5>] --> Delta<Scalar 5>
is 11 _   [Lit: <Scalar 3.14159>] --> Echo<Scalar 3.14159>

test: $(P2B) -CDall "(macro addx (x) (lambda (y) (+ ,x y))) ((addx 4) 5)"
is 0 _ Function: lambda~4 [Signature: <Any> --> <D:return>] called 1 times
is 1 _   Amorphous Mediums:
is 2 _     [Medium: Alfa = root]
is 3 _   Fields:
is 4 _     Bravo: Alfa --> <Any>
is 5 _     Charlie: Alfa --> <Number> OUTPUT
is 6 _     Delta: Alfa --> <Scalar 4>
is 7 _   Operator Instances:
is 8 _     [Parameter 0: y] --> Bravo<Any>
is 9 _     Delta<Scalar 4>, Bravo<Any> --> [+] --> Charlie<Number> OUTPUT
is 10 _     [Lit: <Scalar 4>] --> Delta<Scalar 4>
is 11 _ Amorphous Mediums:
is 12 _   [Medium: Echo = root]
is 13 _ Fields:
is 14 _   Foxtrot: Echo --> <D:return> OUTPUT
is 15 _   Golf: Echo --> <Scalar 5>
is 16 _ Operator Instances:
is 17 _   Golf<Scalar 5> --> [Fun: lambda~4] --> Foxtrot<D:return> OUTPUT
is 18 _   [Lit: <Scalar 5>] --> Golf<Scalar 5>

test: $(P2B) -CDall "(primitive foo (((baz) bar)) zog)"
is 0 _ Error during interpretation:
is 1 _ command-line:1 Error: Compound type must start with symbol: ((baz) bar)
is 2 _ command-line:1 Error: Unknown type zog
is 3 _ Compilation failed.

// This checks ability to have no content to output & arg parsing
test: $(P2B) -CDall "(primitive foo (args) arg2)"
is 0 _ Error during interpretation:
is 1 _  Error: Program has no content.
is 2 _ Compilation failed.

test: $(P2B) -CDall "(primitive foo ((field (field scalar))) scalar)"
is 0 _ Error during interpretation:
is 1 _ command-line:1 Error: Field type must have a local subtype
is 2 _ Compilation failed.

// This test checks handling of malformed type constraints
test: $(P2B) "(primitive zog (any) any :type-constraints foo) (primitive foo (field) any :type-constraints (bluff)) (foo (zog 3))"
is 0 _ Error during analysis:
is 1 _ command-line:1 Error: Expected type constraint to be a list: bluff
is 2 _ command-line:1 Error: Empty type constraint
is 3 _ command-line:1 Error: Expected type constraint to be a list: bluff
is 4 _ command-line:1 Error: Empty type constraint
is 5 _ command-line:1 Error: Expected type constraint set to be a list: foo
is 6 _ Compilation failed.


test: $(P2B) -CDall "(nbr 3)"
is 0 _ Amorphous Mediums:
is 1 _   [Medium: Alfa = root]
is 2 _ Fields:
is 3 _   Bravo: Alfa --> <Field <Any>> OUTPUT
is 4 _   Charlie: Alfa --> <Scalar 3>
is 5 _ Operator Instances:
is 6 _   Charlie<Scalar 3> --> [nbr] --> Bravo<Field <Any>> OUTPUT
is 7 _   [Lit: <Scalar 3>] --> Charlie<Scalar 3>

test: $(P2B) -CDall "(letfed ((x 3 (+ x y 1)) (y 2 (* x 3))) (- x y))"
is 0 _ Amorphous Mediums:
is 1 _   [Medium: Alfa = root]
is 2 _   [Medium: Bravo = Alfa | Charlie]
is 3 _   [Medium: Delta = Alfa | Echo]
is 4 _ Fields:
is 5 _   Charlie: Alfa --> <Boolean>
is 6 _   Echo: Alfa --> <Boolean>
is 7 _   Foxtrot: Alfa --> <Any>
is 8 _   Golf: Delta --> <Local>
is 9 _   Hotel: Bravo --> <Scalar 3>
is 10 _   India: Alfa --> <Any>
is 11 _   Juliet: Delta --> <Local>
is 12 _   Kilo: Bravo --> <Scalar 2>
is 13 _   Lima: Delta --> <Number>
is 14 _   Mike: Delta --> <Scalar 1>
is 15 _   November: Delta --> <Number>
is 16 _   Oscar: Delta --> <Scalar 3>
is 17 _   Papa: Alfa --> <Number> OUTPUT
is 18 _ Operator Instances:
is 19 _   [dchange] --> Charlie<Boolean>
is 20 _   Charlie<Boolean> --> [not] --> Echo<Boolean>
is 21 _   Charlie<Boolean>, Hotel<Scalar 3>, Lima<Number> --> [mux] --> Foxtrot<Any>
is 22 _   Foxtrot<Any> --> [delay] --> Golf<Local>
is 23 _   [Lit: <Scalar 3>] --> Hotel<Scalar 3>
is 24 _   Charlie<Boolean>, Kilo<Scalar 2>, November<Number> --> [mux] --> India<Any>
is 25 _   India<Any> --> [delay] --> Juliet<Local>
is 26 _   [Lit: <Scalar 2>] --> Kilo<Scalar 2>
is 27 _   Golf<Local>, Juliet<Local>, Mike<Scalar 1> --> [+] --> Lima<Number>
is 28 _   [Lit: <Scalar 1>] --> Mike<Scalar 1>
is 29 _   Golf<Local>, Oscar<Scalar 3> --> [*] --> November<Number>
is 30 _   [Lit: <Scalar 3>] --> Oscar<Scalar 3>
is 31 _   Foxtrot<Any>, India<Any> --> [-] --> Papa<Number> OUTPUT

test: $(P2B) -CDall "(rep t 0 (+ t (dt)))"
is 0 _ Amorphous Mediums:
is 1 _  [Medium: Alfa = root]
is 2 _   [Medium: Bravo = Alfa | Charlie]
is 3 _   [Medium: Delta = Alfa | Echo]
is 4 _ Fields:
is 5 _   Charlie: Alfa --> <Boolean>
is 6 _   Echo: Alfa --> <Boolean>
is 7 _   Foxtrot: Alfa --> <Any> OUTPUT
is 8 _   Golf: Delta --> <Local>
is 9 _   Hotel: Bravo --> <Scalar 0>
is 10 _   India: Delta --> <Number>
is 11 _   Juliet: Delta --> <Scalar>
is 12 _ Operator Instances:
is 13 _   [dchange] --> Charlie<Boolean>
is 14 _   Charlie<Boolean> --> [not] --> Echo<Boolean>
is 15 _   Charlie<Boolean>, Hotel<Scalar 0>, India<Number> --> [mux] --> Foxtrot<Any> OUTPUT
is 16 _   Foxtrot<Any> --> [delay] --> Golf<Local>
is 17 _   [Lit: <Scalar 0>] --> Hotel<Scalar 0>
is 18 _   Golf<Local>, Juliet<Scalar> --> [+] --> India<Number>
is 19 _   [dt] --> Juliet<Scalar>
is 20 _ Amorphous Mediums:
is 21 _   [Medium: Alfa = root]
is 22 _   [Medium: Bravo = Alfa | Charlie]
is 23 _   [Medium: Delta = Alfa | Echo]
is 24 _ Fields:
is 25 _   Charlie: Alfa --> <Boolean>
is 26 _   Echo: Alfa --> <Boolean>
is 27 _   Foxtrot: Alfa --> <Scalar> OUTPUT
is 28 _   Golf: Delta --> <Scalar>
is 29 _   Hotel: Bravo --> <Scalar 0>
is 30 _   India: Delta --> <Scalar>
is 31 _   Juliet: Delta --> <Scalar>
is 32 _ Operator Instances:
is 33 _   [dchange] --> Charlie<Boolean>
is 34 _   Charlie<Boolean> --> [not] --> Echo<Boolean>
is 35 _   Charlie<Boolean>, Hotel<Scalar 0>, India<Scalar> --> [mux] --> Foxtrot<Scalar> OUTPUT
is 36 _   Foxtrot<Scalar> --> [delay] --> Golf<Scalar>
is 37 _   [Lit: <Scalar 0>] --> Hotel<Scalar 0>
is 38 _   Golf<Scalar>, Juliet<Scalar> --> [+] --> India<Scalar>
is 39 _   [dt] --> Juliet<Scalar>

test: $(P2B) -CDall "(min-hood (+ 1 (nbr 2)))"
is 0 _ Amorphous Mediums:
is 1 _   [Medium: Alfa = root]
is 2 _ Fields:
is 3 _   Bravo: Alfa --> <D:(ft arg0)> OUTPUT
is 4 _   Charlie: Alfa --> <Number>
is 5 _   Delta: Alfa --> <Scalar 1>
is 6 _   Echo: Alfa --> <D:(fieldof arg0)>
is 7 _   Foxtrot: Alfa --> <Scalar 2>
is 8 _ Operator Instances:
is 9 _   Charlie<Number> --> [min-hood] --> Bravo<D:(ft arg0)> OUTPUT
is 10 _   Delta<Scalar 1>, Echo<D:(fieldof arg0)> --> [+] --> Charlie<Number>
is 11 _   [Lit: <Scalar 1>] --> Delta<Scalar 1>
is 12 _   Foxtrot<Scalar 2> --> [nbr] --> Echo<D:(fieldof arg0)>
is 13 _   [Lit: <Scalar 2>] --> Foxtrot<Scalar 2>
is 14 _ Amorphous Mediums:
is 15 _   [Medium: Alfa = root]
is 16 _ Fields:
is 17 _   Golf: Alfa --> <Scalar 3> OUTPUT
is 18 _ Operator Instances:
is 19 _   [Lit: <Scalar 3>] --> Golf<Scalar 3> OUTPUT

// Testing function call resolving on path; also inlining
test: $(P2B) -CDall "(timer)"
is 0 _ Function: timer [Signature:  --> <D:return>] called 1 times
is 1 _   Amorphous Mediums:
is 2 _     [Medium: Alfa = root]
is 3 _     [Medium: Bravo = Alfa | Charlie]
is 4 _     [Medium: Delta = Alfa | Echo]
is 5 _   Fields:
is 6 _     Charlie: Alfa --> <Boolean>
is 7 _     Echo: Alfa --> <Boolean>
is 8 _     Foxtrot: Alfa --> <D:(lcs arg1 arg2)> OUTPUT
is 9 _     Golf: Delta --> <D:arg0>
is 10 _     Hotel: Bravo --> <Scalar 0>
is 11 _     India: Delta --> <Number>
is 12 _     Juliet: Delta --> <Scalar>
is 13 _   Operator Instances:
is 14 _     [dchange] --> Charlie<Boolean>
is 15 _     Charlie<Boolean> --> [not] --> Echo<Boolean>
is 16 _     Charlie<Boolean>, Hotel<Scalar 0>, India<Number> --> [mux] --> Foxtrot<D:(lcs arg1 arg2)> OUTPUT
is 17 _     Foxtrot<D:(lcs arg1 arg2)> --> [delay] --> Golf<D:arg0>
is 18 _     [Lit: <Scalar 0>] --> Hotel<Scalar 0>
is 19 _     Golf<D:arg0>, Juliet<Scalar> --> [+] --> India<Number>
is 20 _     [dt] --> Juliet<Scalar>
is 21 _ Amorphous Mediums:
is 22 _   [Medium: Kilo = root]
is 23 _ Fields:
is 24 _   Lima: Kilo --> <D:return> OUTPUT
is 25 _ Operator Instances:
is 26 _   [Fun: timer] --> Lima<D:return> OUTPUT
is 27 _ Amorphous Mediums:
is 28 _   [Medium: Kilo = root]
is 29 _   [Medium: Mike = Kilo | November]
is 30 _   [Medium: Oscar = Kilo | Papa]
is 31 _ Fields:
is 32 _   November: Kilo --> <Boolean>
is 33 _   Papa: Kilo --> <Boolean>
is 34 _   Quebec: Kilo --> <Scalar> OUTPUT
is 35 _   Romeo: Mike --> <Scalar 0>
is 36 _   Sierra: Oscar --> <Scalar>
is 37 _   Tango: Oscar --> <Scalar>
is 38 _   Uniform: Oscar --> <Scalar>
is 39 _ Operator Instances:
is 40 _   [dchange] --> November<Boolean>
is 41 _   November<Boolean> --> [not] --> Papa<Boolean>
is 42 _   November<Boolean>, Romeo<Scalar 0>, Tango<Scalar> --> [mux] --> Quebec<Scalar> OUTPUT
is 43 _   [Lit: <Scalar 0>] --> Romeo<Scalar 0>
is 44 _   Quebec<Scalar> --> [delay] --> Sierra<Scalar>
is 45 _   Sierra<Scalar>, Uniform<Scalar> --> [+] --> Tango<Scalar>
is 46 _   [dt] --> Uniform<Scalar>

test: $(P2B) -CDall "(len (tup 3 4))"
is 0 _ Amorphous Mediums:
is 1 _   [Medium: Alfa = root]
is 2 _ Fields:
is 3 _   Bravo: Alfa --> <Scalar> OUTPUT
is 4 _   Charlie: Alfa --> <Tuple<Any>...>
is 5 _   Delta: Alfa --> <Scalar 3>
is 6 _   Echo: Alfa --> <Scalar 4>
is 7 _ Operator Instances:
is 8 _   Charlie<Tuple<Any>...> --> [len] --> Bravo<Scalar> OUTPUT
is 9 _   Delta<Scalar 3>, Echo<Scalar 4> --> [tup] --> Charlie<Tuple<Any>...>
is 10 _  [Lit: <Scalar 3>] --> Delta<Scalar 3>
is 11 _  [Lit: <Scalar 4>] --> Echo<Scalar 4>

test: $(P2B) -CDall "(primitive tupzer ((tuple 3 any)) (vector &rest 4)) (tupzer (tup 3 (nbr 5)))"
is 0 _ Amorphous Mediums:
is 1 _   [Medium: Alfa = root]
is 2 _ Fields:
is 3 _   Bravo: Alfa --> <Vector<Scalar 4>...> OUTPUT
is 4 _   Charlie: Alfa --> <Tuple<Any>...>
is 5 _   Delta: Alfa --> <Scalar 3>
is 6 _   Echo: Alfa --> <Field <Any>>
is 7 _   Foxtrot: Alfa --> <Scalar 5>
is 8 _ Operator Instances:
is 9 _   Charlie<Tuple<Any>...> --> [tupzer] --> Bravo<Vector<Scalar 4>...> OUTPUT
is 10 _   Delta<Scalar 3>, Echo<Field <Any>> --> [tup] --> Charlie<Tuple<Any>...>
is 11 _   [Lit: <Scalar 3>] --> Delta<Scalar 3>
is 12 _   Foxtrot<Scalar 5> --> [nbr] --> Echo<Field <Any>>
is 13 _   [Lit: <Scalar 5>] --> Foxtrot<Scalar 5>

test: $(P2B) -CDall "(primitive tupzer ((tuple 3 any)) (vector &rest number)) (tupzer (tup 3 (nbr 5)))"
is 0 _ Error during interpretation:
is 1 _ command-line:1 Error: Vectors must contain only scalars
is 2 _ Compilation failed.

test: $(P2B) -CDall "(primitive ltest () (lambda (scalar &rest field) local)) (sin (apply (ltest) 2))" --no-analysis
is 0 _ Amorphous Mediums:
is 1 _   [Medium: Alfa = root]
is 2 _ Fields:
is 3 _   Bravo: Alfa --> <Scalar> OUTPUT
is 4 _   Charlie: Alfa --> <Any>
is 5 _   Delta: Alfa --> <Lambda [Op[Signature: <Scalar> &rest <Field <Any>> --> <Local>]]>
is 6 _   Echo: Alfa --> <Scalar 2>
is 7 _ Operator Instances:
is 8 _   Charlie<Any> --> [sin] --> Bravo<Scalar> OUTPUT
is 9 _   Delta<Lambda [Op[Signature: <Scalar> &rest <Field <Any>> --> <Local>]]>, Echo<Scalar 2> --> [apply] --> Charlie<Any>
is 10 _   [ltest] --> Delta<Lambda [Op[Signature: <Scalar> &rest <Field <Any>> --> <Local>]]>
is 11 _   [Lit: <Scalar 2>] --> Echo<Scalar 2>
is 12 _ Stopping before analysis

test: $(P2B) -CDall "(letfed (((tup a b) (tup 7 8) (tup (+ a 1) (* b a)))) (pow a b))"
is 0 _ Amorphous Mediums:
is 1 _   [Medium: Alfa = root]
is 2 _   [Medium: Bravo = Alfa | Charlie]
is 3 _   [Medium: Delta = Alfa | Echo]
is 4 _ Fields:
is 5 _   Charlie: Alfa --> <Boolean>
is 6 _   Echo: Alfa --> <Boolean>
is 7 _   Foxtrot: Alfa --> <Any>
is 8 _   Golf: Delta --> <Local>
is 9 _   Hotel: Alfa --> <Any>
is 10 _   India: Alfa --> <Scalar 0>
is 11 _   Juliet: Alfa --> <Any>
is 12 _   Kilo: Alfa --> <Scalar 1>
is 13 _   Lima: Delta --> <Any>
is 14 _   Mike: Delta --> <Scalar 0>
is 15 _   November: Delta --> <Any>
is 16 _   Oscar: Delta --> <Scalar 1>
is 17 _   Papa: Bravo --> <Tuple<Any>...>
is 18 _   Quebec: Bravo --> <Scalar 7>
is 19 _   Romeo: Bravo --> <Scalar 8>
is 20 _   Sierra: Delta --> <Tuple<Any>...>
is 21 _   Tango: Delta --> <Number>
is 22 _   Uniform: Delta --> <Scalar 1>
is 23 _   Victor: Delta --> <Number>
is 24 _   Whiskey: Alfa --> <Scalar> OUTPUT
is 25 _ Operator Instances:
is 26 _   [dchange] --> Charlie<Boolean>
is 27 _   Charlie<Boolean> --> [not] --> Echo<Boolean>
is 28 _   Charlie<Boolean>, Papa<Tuple<Any>...>, Sierra<Tuple<Any>...> --> [mux] --> Foxtrot<Any>
is 29 _   Foxtrot<Any> --> [delay] --> Golf<Local>
is 30 _   Foxtrot<Any>, India<Scalar 0> --> [elt] --> Hotel<Any>
is 31 _   [Lit: <Scalar 0>] --> India<Scalar 0>
is 32 _   Foxtrot<Any>, Kilo<Scalar 1> --> [elt] --> Juliet<Any>
is 33 _   [Lit: <Scalar 1>] --> Kilo<Scalar 1>
is 34 _   Golf<Local>, Mike<Scalar 0> --> [elt] --> Lima<Any>
is 35 _   [Lit: <Scalar 0>] --> Mike<Scalar 0>
is 36 _   Golf<Local>, Oscar<Scalar 1> --> [elt] --> November<Any>
is 37 _   [Lit: <Scalar 1>] --> Oscar<Scalar 1>
is 38 _   Quebec<Scalar 7>, Romeo<Scalar 8> --> [tup] --> Papa<Tuple<Any>...>
is 39 _   [Lit: <Scalar 7>] --> Quebec<Scalar 7>
is 40 _   [Lit: <Scalar 8>] --> Romeo<Scalar 8>
is 41 _   Tango<Number>, Victor<Number> --> [tup] --> Sierra<Tuple<Any>...>
is 42 _   Lima<Any>, Uniform<Scalar 1> --> [+] --> Tango<Number>
is 43 _   [Lit: <Scalar 1>] --> Uniform<Scalar 1>
is 44 _   November<Any>, Lima<Any> --> [*] --> Victor<Number>
is 45 _   Hotel<Any>, Juliet<Any> --> [pow] --> Whiskey<Scalar> OUTPUT


test: $(P2B) -CDall "(letfed (((tup (tup a b) c) (tup (tup 2 3) 4) (tup (tup a c) b))) c)"
is 0 _ Amorphous Mediums:
is 1 _   [Medium: Alfa = root]
is 2 _   [Medium: Bravo = Alfa | Charlie]
is 3 _   [Medium: Delta = Alfa | Echo]
is 4 _ Fields:
is 5 _   Charlie: Alfa --> <Boolean>
is 6 _   Echo: Alfa --> <Boolean>
is 7 _   Foxtrot: Alfa --> <D:(lcs arg1 arg2)>
is 8 _   Golf: Delta --> <D:arg0>
is 9 _   Hotel: Alfa --> <D:(nth arg0 arg1)>
is 10 _   India: Alfa --> <Scalar 0>
is 11 _   Juliet: Alfa --> <D:(nth arg0 arg1)>
is 12 _   Kilo: Alfa --> <Scalar 0>
is 13 _   Lima: Alfa --> <D:(nth arg0 arg1)>
is 14 _   Mike: Alfa --> <Scalar 1>
is 15 _   November: Alfa --> <D:(nth arg0 arg1)> OUTPUT
is 16 _   Oscar: Alfa --> <Scalar 1>
is 17 _   Papa: Delta --> <D:(nth arg0 arg1)>
is 18 _   Quebec: Delta --> <Scalar 0>
is 19 _   Romeo: Delta --> <D:(nth arg0 arg1)>
is 20 _   Sierra: Delta --> <Scalar 0>
is 21 _   Tango: Delta --> <D:(nth arg0 arg1)>
is 22 _   Uniform: Delta --> <Scalar 1>
is 23 _   Victor: Delta --> <D:(nth arg0 arg1)>
is 24 _   Whiskey: Delta --> <Scalar 1>
is 25 _   Xray: Bravo --> <Tuple<Any>...>
is 26 _   Yankee: Bravo --> <Tuple<Any>...>
is 27 _   Zulu: Bravo --> <Scalar 2>
is 28 _   Plural: Bravo --> <Scalar 3>
is 29 _   Beak: Bravo --> <Scalar 4>
is 30 _   Pronunciation: Delta --> <Tuple<Any>...>
is 31 _   Sow: Delta --> <Tuple<Any>...>
is 32 _ Operator Instances:
is 33 _   [dchange] --> Charlie<Boolean>
is 34 _   Charlie<Boolean> --> [not] --> Echo<Boolean>
is 35 _   Charlie<Boolean>, Xray<Tuple<Any>...>, Pronunciation<Tuple<Any>...> --> [mux] --> Foxtrot<D:(lcs arg1 arg2)>
is 36 _   Foxtrot<D:(lcs arg1 arg2)> --> [delay] --> Golf<D:arg0>
is 37 _   Foxtrot<D:(lcs arg1 arg2)>, India<Scalar 0> --> [elt] --> Hotel<D:(nth arg0 arg1)>
is 38 _   [Lit: <Scalar 0>] --> India<Scalar 0>
is 39 _   Hotel<D:(nth arg0 arg1)>, Kilo<Scalar 0> --> [elt] --> Juliet<D:(nth arg0 arg1)>
is 40 _   [Lit: <Scalar 0>] --> Kilo<Scalar 0>
is 41 _   Hotel<D:(nth arg0 arg1)>, Mike<Scalar 1> --> [elt] --> Lima<D:(nth arg0 arg1)>
is 42 _   [Lit: <Scalar 1>] --> Mike<Scalar 1>
is 43 _   Foxtrot<D:(lcs arg1 arg2)>, Oscar<Scalar 1> --> [elt] --> November<D:(nth arg0 arg1)> OUTPUT
is 44 _   [Lit: <Scalar 1>] --> Oscar<Scalar 1>
is 45 _   Golf<D:arg0>, Quebec<Scalar 0> --> [elt] --> Papa<D:(nth arg0 arg1)>
is 46 _   [Lit: <Scalar 0>] --> Quebec<Scalar 0>
is 47 _   Papa<D:(nth arg0 arg1)>, Sierra<Scalar 0> --> [elt] --> Romeo<D:(nth arg0 arg1)>
is 48 _   [Lit: <Scalar 0>] --> Sierra<Scalar 0>
is 49 _   Papa<D:(nth arg0 arg1)>, Uniform<Scalar 1> --> [elt] --> Tango<D:(nth arg0 arg1)>
is 50 _   [Lit: <Scalar 1>] --> Uniform<Scalar 1>
is 51 _   Golf<D:arg0>, Whiskey<Scalar 1> --> [elt] --> Victor<D:(nth arg0 arg1)>
is 52 _   [Lit: <Scalar 1>] --> Whiskey<Scalar 1>
is 53 _   Yankee<Tuple<Any>...>, Beak<Scalar 4> --> [tup] --> Xray<Tuple<Any>...>
is 54 _   Zulu<Scalar 2>, Plural<Scalar 3> --> [tup] --> Yankee<Tuple<Any>...>
is 55 _   [Lit: <Scalar 2>] --> Zulu<Scalar 2>
is 56 _   [Lit: <Scalar 3>] --> Plural<Scalar 3>
is 57 _   [Lit: <Scalar 4>] --> Beak<Scalar 4>
is 58 _   Sow<Tuple<Any>...>, Tango<D:(nth arg0 arg1)> --> [tup] --> Pronunciation<Tuple<Any>...>
is 59 _   Romeo<D:(nth arg0 arg1)>, Victor<D:(nth arg0 arg1)> --> [tup] --> Sow<Tuple<Any>...>


test: $(P2B) -CDanalyzed "(set-dt (restrict 2 (all (probe (all 3) 1))))"
is 0 _ Amorphous Mediums:
is 1 _   [Medium: Alfa = root]
is 2 _   [Medium: Bravo = Alfa | Charlie]
is 3 _ Fields:
is 4 _   Delta: Alfa --> <Scalar 3> OUTPUT
is 5 _   Charlie: Alfa --> <Scalar 2>
is 6 _   Echo: Bravo --> <Scalar 3>
is 7 _   Foxtrot: Bravo --> <Scalar 3>
is 8 _   Golf: Bravo --> <Scalar 1>
is 9 _ Operator Instances:
is 10 _   Echo<Scalar 3> --> [set-dt] --> Delta<Scalar 3> OUTPUT
is 11 _   [Lit: <Scalar 2>] --> Charlie<Scalar 2>
is 12 _   Foxtrot<Scalar 3>, Golf<Scalar 1> --> [probe] --> Echo<Scalar 3>
is 13 _   [Lit: <Scalar 3>] --> Foxtrot<Scalar 3>
is 14 _   [Lit: <Scalar 1>] --> Golf<Scalar 1>

test: $(P2B) -CDanalyzed "(/ (/ (tup 3 4) 5) (rnd 0 1))"
is 0 _ Amorphous Mediums:
is 1 _   [Medium: Alfa = root]
is 2 _ Fields:
is 3 _   Bravo: Alfa --> <2-Vector<Scalar>,<Scalar>> OUTPUT
is 4 _   Charlie: Alfa --> <Scalar>
is 5 _   Delta: Alfa --> <Scalar 0>
is 6 _   Echo: Alfa --> <Scalar 1>
is 7 _   Foxtrot: Alfa --> <2-Vector<Scalar 0.6>,<Scalar 0.8>>
is 8 _ Operator Instances:
is 9 _   Foxtrot<2-Vector<Scalar 0.6>,<Scalar 0.8>>, Charlie<Scalar> --> [/] --> Bravo<2-Vector<Scalar>,<Scalar>> OUTPUT
is 10 _   Delta<Scalar 0>, Echo<Scalar 1> --> [rnd] --> Charlie<Scalar>
is 11 _   [Lit: <Scalar 0>] --> Delta<Scalar 0>
is 12 _   [Lit: <Scalar 1>] --> Echo<Scalar 1>
is 13 _   [Lit: <2-Vector<Scalar 0.6>,<Scalar 0.8>>] --> Foxtrot<2-Vector<Scalar 0.6>,<Scalar 0.8>>

test: $(P2B) -CDanalyzed "(elt (tup 3 4) 0)"
is 0 _ Amorphous Mediums:
is 1 _   [Medium: Alfa = root]
is 2 _ Fields:
is 3 _   Bravo: Alfa --> <Scalar 3> OUTPUT
is 4 _ Operator Instances:
is 5 _   [Lit: <Scalar 3>] --> Bravo<Scalar 3> OUTPUT

test: $(P2B) -CDanalyzed "(elt 7)"
is 0 _ Error during interpretation:
is 1 _ command-line:1 Error: Called [elt] with 1 arguments; it requires exactly 2
is 2 _ Compilation failed.


test: $(P2B) -CDanalyzed "(+ 2 (sqrt 3) 4 (> 5 6))"
is 0 _ Amorphous Mediums:
is 1 _   [Medium: Alfa = root]
is 2 _ Fields:
is 3 _   Bravo: Alfa --> <Scalar 7.73205> OUTPUT
is 4 _ Operator Instances:
is 5 _   [Lit: <Scalar 7.73205>] --> Bravo<Scalar 7.73205> OUTPUT

test: $(P2B) -CDanalyzed "(> (tup 1 0 0 -4) 1)"
is 0 _ Amorphous Mediums:
is 1 _   [Medium: Alfa = root]
is 2 _ Fields:
is 3 _   Bravo: Alfa --> <Boolean false> OUTPUT
is 4 _ Operator Instances:
is 5 _   [Lit: <Boolean false>] --> Bravo<Boolean false> OUTPUT

test: $(P2B) -CDanalyzed "(elt '(3 (1 val) 5) (elt '(2 2 2) (rnd 1 2)))"
is 0 _ Amorphous Mediums:
is 1 _   [Medium: Alfa = root]
is 2 _ Fields:
is 3 _   Bravo: Alfa --> <Scalar 5> OUTPUT
is 4 _ Operator Instances:
is 5 _   [Lit: <Scalar 5>] --> Bravo<Scalar 5> OUTPUT

test: $(P2B) -CDanalyzed "(rep x 3 (elt (tup x 7) 0))"
is 0 _ Amorphous Mediums:
is 1 _   [Medium: Alfa = root]
is 2 _   [Medium: Bravo = Alfa | Charlie]
is 3 _   [Medium: Delta = Alfa | Echo]
is 4 _ Fields:
is 5 _   Charlie: Alfa --> <Boolean>
is 6 _   Echo: Alfa --> <Boolean>
is 7 _   Foxtrot: Alfa --> <Scalar> OUTPUT
is 8 _   Golf: Delta --> <Scalar>
is 9 _   Hotel: Bravo --> <Scalar 3>
is 10 _   India: Delta --> <Scalar>
is 11 _   Juliet: Delta --> <2-Tuple<Scalar>,<Scalar 7>>
is 12 _   Kilo: Delta --> <Scalar 7>
is 13 _   Lima: Delta --> <Scalar 0>
is 14 _ Operator Instances:
is 15 _   [dchange] --> Charlie<Boolean>
is 16 _   Charlie<Boolean> --> [not] --> Echo<Boolean>
is 17 _   Charlie<Boolean>, Hotel<Scalar 3>, India<Scalar> --> [mux] --> Foxtrot<Scalar> OUTPUT
is 18 _   Foxtrot<Scalar> --> [delay] --> Golf<Scalar>
is 19 _   [Lit: <Scalar 3>] --> Hotel<Scalar 3>
is 20 _   Juliet<2-Tuple<Scalar>,<Scalar 7>>, Lima<Scalar 0> --> [elt] --> India<Scalar>
is 21 _   Golf<Scalar>, Kilo<Scalar 7> --> [tup] --> Juliet<2-Tuple<Scalar>,<Scalar 7>>
is 22 _   [Lit: <Scalar 7>] --> Kilo<Scalar 7>
is 23 _   [Lit: <Scalar 0>] --> Lima<Scalar 0>

// Test all-folding
test: $(P2B) -CDanalyzed "(all 1 (all (set-dt 2) (all 3)))"
is 0 _ Amorphous Mediums:
is 1 _   [Medium: Alfa = root]
is 2 _ Fields:
is 3 _   Bravo: Alfa --> <Scalar 2>
is 4 _   Charlie: Alfa --> <Scalar 2>
is 5 _   Delta: Alfa --> <Scalar 3> OUTPUT
is 6 _ Operator Instances:
is 7 _   Charlie<Scalar 2> --> [set-dt] --> Bravo<Scalar 2>
is 8 _   [Lit: <Scalar 2>] --> Charlie<Scalar 2>
is 9 _   [Lit: <Scalar 3>] --> Delta<Scalar 3> OUTPUT

// Test dead-code elimination
test: $(P2B) -CDanalyzed "(let ((x (* 7 (mov '(2 3))))) 4)"
is 0 _ Amorphous Mediums:
is 1 _   [Medium: Alfa = root]
is 2 _ Fields:
is 3 _   Bravo: Alfa --> <2-Vector<Scalar 2>,<Scalar 3>>
is 4 _   Charlie: Alfa --> <2-Vector<Scalar 2>,<Scalar 3>>
is 5 _   Delta: Alfa --> <Scalar 4> OUTPUT
is 6 _ Operator Instances:
is 7 _   Charlie<2-Vector<Scalar 2>,<Scalar 3>> --> [mov] --> Bravo<2-Vector<Scalar 2>,<Scalar 3>>
is 8 _   [Lit: <2-Vector<Scalar 2>,<Scalar 3>>] --> Charlie<2-Vector<Scalar 2>,<Scalar 3>>
is 9 _   [Lit: <Scalar 4>] --> Delta<Scalar 4> OUTPUT

// Test unused space elimination
test: $(P2B) -CDanalyzed "(if 1 2 2)"
is 0 _ Amorphous Mediums:
is 1 _   [Medium: Alfa = root]
is 2 _ Fields:
is 3 _   Bravo: Alfa --> <Scalar 2> OUTPUT
is 4 _ Operator Instances:
is 5 _   [Lit: <Scalar 2>] --> Bravo<Scalar 2> OUTPUT

// Basic funcall handling & simplification:
test: $(P2B) -CDanalyzed "(muxand true false)"
is 0 _ Amorphous Mediums:
is 1 _   [Medium: Alfa = root]
is 2 _ Fields:
is 3 _   Bravo: Alfa --> <Boolean false> OUTPUT
is 4 _ Operator Instances:
is 5 _   [Lit: <Boolean false>] --> Bravo<Boolean false> OUTPUT

// funcall usage tracking:
test: $(P2B) -CDanalyzed "(def foo () (mid)) (def bar (x) (+ 3 x)) (nbr (tup foo bar (tup foo)))"
is 0 _ Function: foo [Signature:  --> <D:return>] called 2 times
is 1 _   Amorphous Mediums:
is 2 _     [Medium: Alfa = root]
is 3 _   Fields:
is 4 _     Bravo: Alfa --> <Scalar> OUTPUT
is 5 _   Operator Instances:
is 6 _     [mid] --> Bravo<Scalar> OUTPUT
is 7 _ Function: bar [Signature: <Any> --> <D:return>] called 1 times
is 8 _   Amorphous Mediums:
is 9 _     [Medium: Charlie = root]
is 10 _   Fields:
is 11 _     Delta: Charlie --> <Number>
is 12 _     Echo: Charlie --> <Number> OUTPUT
is 13 _     Foxtrot: Charlie --> <Scalar 3>
is 14 _   Operator Instances:
is 15 _     [Parameter 0: x] --> Delta<Number>
is 16 _     Foxtrot<Scalar 3>, Delta<Number> --> [+] --> Echo<Number> OUTPUT
is 17 _     [Lit: <Scalar 3>] --> Foxtrot<Scalar 3>
is 18 _ Amorphous Mediums:
is 19 _   [Medium: Golf = root]
is 20 _ Fields:
is 21 _   Hotel: Golf --> <D:(fieldof arg0)> OUTPUT
is 22 _   India: Golf --> <Tuple<Any>...>
is 23 _   Juliet: Golf --> <Lambda [Fun: foo]>
is 24 _   Kilo: Golf --> <Lambda [Fun: bar]>
is 25 _   Lima: Golf --> <Tuple<Any>...>
is 26 _   Mike: Golf --> <Lambda [Fun: foo]>
is 27 _ Operator Instances:
is 28 _   India<Tuple<Any>...> --> [nbr] --> Hotel<D:(fieldof arg0)> OUTPUT
is 29 _   Juliet<Lambda [Fun: foo]>, Kilo<Lambda [Fun: bar]>, Lima<Tuple<Any>...> --> [tup] --> India<Tuple<Any>...>
is 30 _   [Lit: <Lambda [Fun: foo]>] --> Juliet<Lambda [Fun: foo]>
is 31 _   [Lit: <Lambda [Fun: bar]>] --> Kilo<Lambda [Fun: bar]>
is 32 _   Mike<Lambda [Fun: foo]> --> [tup] --> Lima<Tuple<Any>...>
is 33 _   [Lit: <Lambda [Fun: foo]>] --> Mike<Lambda [Fun: foo]>


// funcall propagation & backpropagation
test: $(P2B) -CDanalyzed "(+ ((lambda (x) 2) 4) ((lambda (x y) (mux (dt) x y)) 3 3))"
is 0 _ Amorphous Mediums:
is 1 _   [Medium: Alfa = root]
is 2 _ Fields:
is 3 _   Bravo: Alfa --> <Scalar 5> OUTPUT
is 4 _ Operator Instances:
is 5 _   [Lit: <Scalar 5>] --> Bravo<Scalar 5> OUTPUT

// letfed w. multiple statements, some of which are pruned
test: $(P2B) -CDanalyzed "(letfed ((x 0 (- 1 x))) (set-dt x) 2 (- x 3))"
is 0 _ Amorphous Mediums:
is 1 _   [Medium: Alfa = root]
is 2 _   [Medium: Bravo = Alfa | Charlie]
is 3 _   [Medium: Delta = Alfa | Echo]
is 4 _ Fields:
is 5 _   Charlie: Alfa --> <Boolean>
is 6 _   Echo: Alfa --> <Boolean>
is 7 _   Foxtrot: Alfa --> <Scalar>
is 8 _   Golf: Delta --> <Scalar>
is 9 _   Hotel: Bravo --> <Scalar 0>
is 10 _   India: Delta --> <Scalar>
is 11 _   Juliet: Delta --> <Scalar 1>
is 12 _   Kilo: Alfa --> <Scalar>
is 13 _   Lima: Alfa --> <Scalar> OUTPUT
is 14 _   Mike: Alfa --> <Scalar 3>
is 15 _ Operator Instances:
is 16 _   [dchange] --> Charlie<Boolean>
is 17 _   Charlie<Boolean> --> [not] --> Echo<Boolean>
is 18 _   Charlie<Boolean>, Hotel<Scalar 0>, India<Scalar> --> [mux] --> Foxtrot<Scalar>
is 19 _   Foxtrot<Scalar> --> [delay] --> Golf<Scalar>
is 20 _   [Lit: <Scalar 0>] --> Hotel<Scalar 0>
is 21 _   Juliet<Scalar 1>, Golf<Scalar> --> [-] --> India<Scalar>
is 22 _   [Lit: <Scalar 1>] --> Juliet<Scalar 1>
is 23 _   Foxtrot<Scalar> --> [set-dt] --> Kilo<Scalar>
is 24 _   Foxtrot<Scalar>, Mike<Scalar 3> --> [-] --> Lima<Scalar> OUTPUT
is 25 _   [Lit: <Scalar 3>] --> Mike<Scalar 3>

// Testing propagation in & out of funcall
test: $(P2B) -CDanalyzed "((lambda (x) (set-dt x)) 5)" --function-inlining-threshold 0
is 0 _ Function: lambda~4 [Signature: <Any> --> <D:return>] called 1 times
is 1 _   Amorphous Mediums:
is 2 _     [Medium: Alfa = root]
is 3 _   Fields:
is 4 _     Bravo: Alfa --> <Scalar 5> OUTPUT
is 5 _     Charlie: Alfa --> <Scalar 5>
is 6 _   Operator Instances:
is 7 _     Charlie<Scalar 5> --> [set-dt] --> Bravo<Scalar 5> OUTPUT
is 8 _     [Lit: <Scalar 5>] --> Charlie<Scalar 5>
is 9 _ Amorphous Mediums:
is 10 _   [Medium: Delta = root]
is 11 _ Fields:
is 12 _   Echo: Delta --> <Scalar 5> OUTPUT
is 13 _   Foxtrot: Delta --> <Scalar 5>
is 14 _ Operator Instances:
is 15 _   Foxtrot<Scalar 5> --> [Fun: lambda~4] --> Echo<Scalar 5> OUTPUT
is 16 _   [Lit: <Scalar 5>] --> Foxtrot<Scalar 5>

// should end up with 1 timer call
test: $(P2B) -CDanalyzed "(all (timer) (timer))" --function-inlining-threshold 0
is 0 _  Function: timer [Signature:  --> <D:return>] called 1 times
is 21 _ Amorphous Mediums:
is 22 _   [Medium: Kilo = root]
is 23 _ Fields:
is 24 _   Lima: Kilo --> <Scalar> OUTPUT
is 25 _ Operator Instances:
is 26 _   [Fun: timer] --> Lima<Scalar> OUTPUT

test: $(P2B) -CDanalyzed "(/ 2 3 4)"
is 5 _   [Lit: <Scalar 0.166667>] --> Bravo<Scalar 0.166667> OUTPUT
is 6 _ Stopping before localization

test: $(P2B) -CDanalyzed "(if (rnd 0 1) (if true 3 5) (if (mid) 3 3))"
is 5 _   [Lit: <Scalar 3>] --> Bravo<Scalar 3> OUTPUT
is 6 _ Stopping before localization

// promotion of pointwise to field ops
test: $(P2B) -CDanalyzed "(sin (nbr 3))"
is 0 _ Amorphous Mediums:
is 1 _   [Medium: Alfa = root]
is 2 _ Fields:
is 3 _   Bravo: Alfa --> <Field <Scalar 0.14112>> OUTPUT
is 4 _ Operator Instances:
is 5 _   [Lit: <Field <Scalar 0.14112>>] --> Bravo<Field <Scalar 0.14112>> OUTPUT
is 6 _ Stopping before localization

// Test is broken because new type-propagator system is incomplete
//test: $(P2B) -CDanalyzed "(min-hood (sin (nbr 3)))"
//is 0 _ Amorphous Mediums:
//is 1 _   [Medium: Alfa = root]
//is 2 _ Fields:
//is 3 _   Bravo: Alfa --> <Scalar 0.14112> OUTPUT
//is 4 _ Operator Instances:
//is 5 _   [Lit: <Scalar 0.14112>] --> Bravo<Scalar 0.14112> OUTPUT
//is 6 _ Stopping before localization

// insertion of "local" ops
test: $(P2B) -CDanalyzed "(int-hood 1)"
is 0 _ Amorphous Mediums:
is 1 _   [Medium: Alfa = root]
is 2 _ Fields:
is 3 _   Bravo: Alfa --> <Scalar> OUTPUT
is 4 _   Charlie: Alfa --> <Field <Scalar 1>>
is 5 _ Operator Instances:
is 6 _   Charlie<Field <Scalar 1>> --> [int-hood] --> Bravo<Scalar> OUTPUT
is 7 _   [Lit: <Field <Scalar 1>>] --> Charlie<Field <Scalar 1>>
is 8 _ Stopping before localization

test: $(P2B) -CDanalyzed "(min-hood (+ (nbr-range) (nbr (mid))))"
is 0 _ Amorphous Mediums:
is 1 _   [Medium: Alfa = root]
is 2 _ Fields:
is 3 _   Bravo: Alfa --> <Scalar> OUTPUT
is 4 _   Charlie: Alfa --> <Field <Scalar>>
is 5 _   Delta: Alfa --> <Field <Scalar>>
is 6 _   Echo: Alfa --> <Field <Scalar>>
is 7 _   Foxtrot: Alfa --> <Scalar>
is 8 _ Operator Instances:
is 9 _   Charlie<Field <Scalar>> --> [min-hood] --> Bravo<Scalar> OUTPUT
is 10 _   Delta<Field <Scalar>>, Echo<Field <Scalar>> --> [Field~~+] --> Charlie<Field <Scalar>>
is 11 _   [nbr-range] --> Delta<Field <Scalar>>
is 12 _   Foxtrot<Scalar> --> [nbr] --> Echo<Field <Scalar>>
is 13 _   [mid] --> Foxtrot<Scalar>
is 14 _ Stopping before localization

test: $(P2B) -CDanalyzed "(max-hood (* (mid) (+ (nbr (speed)) 1)))"
is 0 _ Amorphous Mediums:
is 1 _   [Medium: Alfa = root]
is 2 _ Fields:
is 3 _   Bravo: Alfa --> <Scalar> OUTPUT
is 4 _   Charlie: Alfa --> <Field <Scalar>>
is 5 _   Delta: Alfa --> <Field <Scalar>>
is 6 _   Echo: Alfa --> <Field <Scalar>>
is 7 _   Foxtrot: Alfa --> <Scalar>
is 8 _   Golf: Alfa --> <Field <Scalar>>
is 9 _   Hotel: Alfa --> <Field <Scalar 1>>
is 10 _ Operator Instances:
is 11 _   Charlie<Field <Scalar>> --> [max-hood] --> Bravo<Scalar> OUTPUT
is 12 _   Golf<Field <Scalar>>, Delta<Field <Scalar>> --> [Field~~*] --> Charlie<Field <Scalar>>
is 13 _   Echo<Field <Scalar>>, Hotel<Field <Scalar 1>> --> [Field~~+] --> Delta<Field <Scalar>>
is 14 _   Foxtrot<Scalar> --> [nbr] --> Echo<Field <Scalar>>
is 15 _   [speed] --> Foxtrot<Scalar>
is 16 _   [Field~~mid] --> Golf<Field <Scalar>>
is 17 _   [Lit: <Field <Scalar 1>>] --> Hotel<Field <Scalar 1>>
is 18 _ Stopping before localization

// Test inlining
test: $(P2B) -CDanalyzed "(def foo (x) (+ 1 x)) (def bar (x y) (* x y)) (bar (foo (foo (mid))) (bar (foo (mid)) (foo 3)))" --function-inlining-threshold -1
is 0 _ Amorphous Mediums:
is 1 _   [Medium: Alfa = root]
is 2 _ Fields:
is 3 _   Bravo: Alfa --> <Scalar>
is 4 _   Charlie: Alfa --> <Scalar>
is 5 _   Delta: Alfa --> <Scalar> OUTPUT
is 6 _   Echo: Alfa --> <Scalar>
is 7 _   Foxtrot: Alfa --> <Scalar 1>
is 8 _   Golf: Alfa --> <Scalar>
is 9 _   Hotel: Alfa --> <Scalar 1>
is 10 _   India: Alfa --> <Scalar>
is 11 _   Juliet: Alfa --> <Scalar>
is 12 _   Kilo: Alfa --> <Scalar 1>
is 13 _   Lima: Alfa --> <Scalar 4>
is 14 _ Operator Instances:
is 15 _   [mid] --> Bravo<Scalar>
is 16 _   [mid] --> Charlie<Scalar>
is 17 _   Echo<Scalar>, India<Scalar> --> [*] --> Delta<Scalar> OUTPUT
is 18 _   Foxtrot<Scalar 1>, Golf<Scalar> --> [+] --> Echo<Scalar>
is 19 _   [Lit: <Scalar 1>] --> Foxtrot<Scalar 1>
is 20 _   Hotel<Scalar 1>, Bravo<Scalar> --> [+] --> Golf<Scalar>
is 21 _   [Lit: <Scalar 1>] --> Hotel<Scalar 1>
is 22 _   Juliet<Scalar>, Lima<Scalar 4> --> [*] --> India<Scalar>
is 23 _   Kilo<Scalar 1>, Charlie<Scalar> --> [+] --> Juliet<Scalar>
is 24 _   [Lit: <Scalar 1>] --> Kilo<Scalar 1>
is 25 _   [Lit: <Scalar 4>] --> Lima<Scalar 4>

// Test nested inlining
test: $(P2B) -CDanalyzed "(def foo (x) (sqrt x)) (def bar (x) (+ (foo x) (foo x))) (def qux (x) (* (foo x) (bar x) (foo x))) (qux (mid))" --function-inlining-threshold -1
is 0 _ Amorphous Mediums:
is 1 _   [Medium: Alfa = root]
is 2 _ Fields:
is 3 _   Bravo: Alfa --> <Scalar>
is 4 _   Charlie: Alfa --> <Scalar> OUTPUT
is 5 _   Delta: Alfa --> <Scalar>
is 6 _   Echo: Alfa --> <Scalar>
is 7 _   Foxtrot: Alfa --> <Scalar>
is 8 _   Golf: Alfa --> <Scalar>
is 9 _   Hotel: Alfa --> <Scalar>
is 10 _ Operator Instances:
is 11 _   [mid] --> Bravo<Scalar>
is 12 _   Delta<Scalar>, Echo<Scalar>, Hotel<Scalar> --> [*] --> Charlie<Scalar> OUTPUT
is 13 _   Bravo<Scalar> --> [sqrt] --> Delta<Scalar>
is 14 _   Foxtrot<Scalar>, Golf<Scalar> --> [+] --> Echo<Scalar>
is 15 _   Bravo<Scalar> --> [sqrt] --> Foxtrot<Scalar>
is 16 _   Bravo<Scalar> --> [sqrt] --> Golf<Scalar>
is 17 _   Bravo<Scalar> --> [sqrt] --> Hotel<Scalar>



// make sure restrictions happen on cross-domain boundaries
test: $(P2B) -CDanalyzed "(let ((x (+ (mid) 1))) (if (rnd 0 1) x 3))"
is 0 _ Amorphous Mediums:
is 1 _   [Medium: Alfa = root]
is 2 _   [Medium: Bravo = Alfa | Charlie]
is 3 _   [Medium: Delta = Alfa | Echo]
is 4 _ Fields:
is 5 _   Foxtrot: Alfa --> <Scalar>
is 6 _   Golf: Alfa --> <Scalar>
is 7 _   Hotel: Alfa --> <Scalar 1>
is 8 _   Charlie: Alfa --> <Scalar>
is 9 _   India: Alfa --> <Scalar 0>
is 10 _   Juliet: Alfa --> <Scalar 1>
is 11 _   Kilo: Alfa --> <Scalar> OUTPUT
is 12 _   Lima: Bravo --> <Scalar>
is 13 _   Echo: Alfa --> <Boolean>
is 14 _   Mike: Delta --> <Scalar 3>
is 15 _ Operator Instances:
is 16 _   Golf<Scalar>, Hotel<Scalar 1> --> [+] --> Foxtrot<Scalar>
is 17 _   [mid] --> Golf<Scalar>
is 18 _   [Lit: <Scalar 1>] --> Hotel<Scalar 1>
is 19 _   India<Scalar 0>, Juliet<Scalar 1> --> [rnd] --> Charlie<Scalar>
is 20 _   [Lit: <Scalar 0>] --> India<Scalar 0>
is 21 _   [Lit: <Scalar 1>] --> Juliet<Scalar 1>
is 22 _   Charlie<Scalar>, Lima<Scalar>, Mike<Scalar 3> --> [mux] --> Kilo<Scalar> OUTPUT
is 23 _   Charlie<Scalar>, Foxtrot<Scalar> --> [restrict] --> Lima<Scalar>
is 24 _   Charlie<Scalar> --> [not] --> Echo<Boolean>
is 25 _   [Lit: <Scalar 3>] --> Mike<Scalar 3>

// NEIGHORHOOD OPERATIONS
// Simple neighborhood:
test: $(P2B) -CDanalyzed -CDlocalized "(max-hood (nbr (= (mid) 0)))"
is 0 _ Amorphous Mediums:
is 1 _   [Medium: Alfa = root]
is 2 _ Fields:
is 3 _   Bravo: Alfa --> <Boolean> OUTPUT
is 4 _   Charlie: Alfa --> <Field <Boolean>>
is 5 _   Delta: Alfa --> <Boolean>
is 6 _   Echo: Alfa --> <Scalar>
is 7 _   Foxtrot: Alfa --> <Scalar 0>
is 8 _ Operator Instances:
is 9 _   Charlie<Field <Boolean>> --> [max-hood] --> Bravo<Boolean> OUTPUT
is 10 _   Delta<Boolean> --> [nbr] --> Charlie<Field <Boolean>>
is 11 _   Echo<Scalar>, Foxtrot<Scalar 0> --> [=] --> Delta<Boolean>
is 12 _   [mid] --> Echo<Scalar>
is 13 _   [Lit: <Scalar 0>] --> Foxtrot<Scalar 0>
//is 14 _ Function: lambda~4 [Signature: <Boolean> --> <D:return>] called 1 times
//is 15 _   Amorphous Mediums:
//is 16 _     [Medium: Golf = root]
//is 17 _   Fields:
//is 18 _     Hotel: Golf --> <Local>
//is 19 _     India: Golf --> <Field <Local>> OUTPUT
//is 20 _   Operator Instances:
//is 21 _     [Parameter 0: arg~5] --> Hotel<Local>
//is 22 _     Hotel<Local> --> [nbr] --> India<Field <Local>> OUTPUT
//is 23 _ Amorphous Mediums:
//is 24 _   [Medium: Alfa = root]
//is 25 _ Fields:
//is 26 _   Delta: Alfa --> <Boolean>
//is 27 _   Echo: Alfa --> <Scalar>
//is 28 _   Foxtrot: Alfa --> <Scalar 0>
//is 29 _   Juliet: Alfa --> <Number> OUTPUT
//is 30 _   Kilo: Alfa --> <Lambda [max]>
//is 31 _   Lima: Alfa --> <Lambda [Fun: lambda~4]>
//is 32 _ Operator Instances:
//is 33 _   Echo<Scalar>, Foxtrot<Scalar 0> --> [=] --> Delta<Boolean>
//is 34 _   [mid] --> Echo<Scalar>
//is 35 _   [Lit: <Scalar 0>] --> Foxtrot<Scalar 0>
//is 36 _   Kilo<Lambda [max]>, Lima<Lambda [Fun: lambda~4]>, Delta<Boolean> --> [fold-hood-plus] --> Juliet<Number> OUTPUT
//is 37 _   [Lit: <Lambda [max]>] --> Kilo<Lambda [max]>
//is 38 _   [Lit: <Lambda [Fun: lambda~4]>] --> Lima<Lambda [Fun: lambda~4]>

// references in lambdas to external variables
// test: $(P2B) -CDanalyzed "(let ((x (+ (mid) 1))) ((lambda (y) (* x y)) 3))"
// is 0 _ Amorphous Mediums:

// Neighborhood variables: "(let ((x (mid))) (+ x (min-hood (+ x (nbr x)))))"
// Neighborhood variables: "(let ((x (+ 2 (mid)))) (+ x (min-hood (+ x (nbr x)))))"

// test: $(P2B) -CDanalyzed "(def foo (x) (+ x (mid))) (apply foo (- (mid) 1))"
// test: $(P2B) -CDanalyzed "(apply / `(8 12) 2 3)"

// check pointwise computation allowing raising of compound op to field
// demonstrate that space, time ops can't be raised to field ops
// test scalar/vector-1 conversion


// For later:
// Get "(rep x 3 (elt (tup x 7) 0))" to realize that it's got a constant output of 3
// test: $(P2B) -CDall "(def addz (a b &optional (c 3)) (+ a b c)) (addz 1 2)"
